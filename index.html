<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2048 â€” Aurora Edition</title>
  <style>
    :root {
      --bg: #050812;
      --bg-gradient: radial-gradient(120% 120% at 18% 20%, #12315a, #060c1e 52%) no-repeat,
                     radial-gradient(80% 80% at 82% 10%, #351049, transparent 58%) no-repeat,
                     radial-gradient(140% 120% at 30% 100%, #0f2f3f, transparent 52%) no-repeat,
                     #050812;
      --glow-layers:
        radial-gradient(320px 320px at 25% 20%, rgba(135, 246, 255, 0.24), transparent 60%),
        radial-gradient(260px 260px at 80% 25%, rgba(255, 177, 227, 0.18), transparent 55%),
        radial-gradient(220px 220px at 70% 80%, rgba(103, 201, 255, 0.2), transparent 60%);
      --panel: rgba(255, 255, 255, 0.06);
      --panel-strong: rgba(255, 255, 255, 0.12);
      --text: #e8f2ff;
      --muted: #9fb8dc;
      --accent: #87f6ff;
      --accent-strong: #64ddf3;
      --grid: rgba(255, 255, 255, 0.1);
      --tile-shadow: 0 14px 40px rgba(0, 0, 0, 0.35);
      --tile-2-bg: linear-gradient(135deg, #a6f4ff, #35d6ff);
      --tile-2-text: #032135;
      --tile-4-bg: linear-gradient(135deg, #c7c1ff, #8a7bff);
      --tile-4-text: #1b123d;
      --tile-8-bg: linear-gradient(135deg, #ffe7c2, #f9b572);
      --tile-8-text: #3c1c05;
      --tile-16-bg: linear-gradient(135deg, #ffd5b3, #f78e69);
      --tile-16-text: #3a1504;
      --tile-32-bg: linear-gradient(135deg, #ffc6c3, #f46b75);
      --tile-32-text: #32090d;
      --tile-64-bg: linear-gradient(135deg, #ffb4d3, #f15bb5);
      --tile-64-text: #300522;
      --tile-128-bg: linear-gradient(135deg, #f6d9ff, #d0b3ff);
      --tile-128-text: #2a103f;
      --tile-256-bg: linear-gradient(135deg, #e3d8ff, #b6a4ff);
      --tile-256-text: #24103d;
      --tile-512-bg: linear-gradient(135deg, #d8f0ff, #8fe1ff);
      --tile-512-text: #04213a;
      --tile-1024-bg: linear-gradient(135deg, #c9fff3, #7cf2c9);
      --tile-1024-text: #032725;
      --tile-2048-bg: linear-gradient(135deg, #d8ffe2, #80ffbe);
      --tile-2048-text: #0c2d20;
      --tile-4096-bg: linear-gradient(135deg, #f1f6ff, #9ad7ff);
      --tile-4096-text: #08203f;
      --cell-size: clamp(48px, 22vw, 96px);
      font-family: "Sora", "Space Grotesk", "Manrope", "DM Sans", "Inter", system-ui, -apple-system, sans-serif;
    }

    body.theme-dawn {
      --bg: #0d0a18;
      --bg-gradient: radial-gradient(120% 120% at 18% 20%, #2a214f, #0d0a18 56%) no-repeat,
                     radial-gradient(90% 80% at 80% 0%, #602a61, transparent 58%) no-repeat,
                     radial-gradient(130% 120% at 40% 100%, #2c1d3e, transparent 50%) no-repeat,
                     #0d0a18;
      --glow-layers:
        radial-gradient(320px 320px at 25% 20%, rgba(255, 201, 124, 0.28), transparent 60%),
        radial-gradient(260px 260px at 75% 18%, rgba(255, 140, 178, 0.22), transparent 55%),
        radial-gradient(220px 220px at 70% 78%, rgba(147, 193, 255, 0.2), transparent 60%);
      --panel: rgba(255, 255, 255, 0.07);
      --panel-strong: rgba(255, 255, 255, 0.14);
      --text: #fdf2ff;
      --muted: #c5b3d7;
      --accent: #ffb374;
      --accent-strong: #ff9f5f;
      --grid: rgba(255, 255, 255, 0.14);
      --tile-shadow: 0 14px 40px rgba(0, 0, 0, 0.4);
      --tile-2-bg: linear-gradient(135deg, #ffd8a5, #ffb66b);
      --tile-2-text: #3b1702;
      --tile-4-bg: linear-gradient(135deg, #ffc5b1, #ff9573);
      --tile-4-text: #35110a;
      --tile-8-bg: linear-gradient(135deg, #ffd3c7, #ff9e8f);
      --tile-8-text: #321010;
      --tile-16-bg: linear-gradient(135deg, #ffc7df, #f57fb6);
      --tile-16-text: #30101e;
      --tile-32-bg: linear-gradient(135deg, #f5d0ff, #d989ff);
      --tile-32-text: #2a0f33;
      --tile-64-bg: linear-gradient(135deg, #e0d7ff, #a99aff);
      --tile-64-text: #1f1542;
      --tile-128-bg: linear-gradient(135deg, #d4e3ff, #97b9ff);
      --tile-128-text: #0d2041;
      --tile-256-bg: linear-gradient(135deg, #cdefff, #87e1ff);
      --tile-256-text: #07263b;
      --tile-512-bg: linear-gradient(135deg, #d8ffe7, #86ffb5);
      --tile-512-text: #0c2b1c;
      --tile-1024-bg: linear-gradient(135deg, #f2ffd9, #d6ff8a);
      --tile-1024-text: #1d2d0c;
      --tile-2048-bg: linear-gradient(135deg, #fff2d8, #ffbc6b);
      --tile-2048-text: #3a1e00;
      --tile-4096-bg: linear-gradient(135deg, #f1f6ff, #9ad7ff);
      --tile-4096-text: #08203f;
      --cell-size: clamp(48px, 22vw, 96px);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg-gradient);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 32px;
    }

    .glow {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: var(--glow-layers);
      filter: blur(30px);
      z-index: 0;
    }

    .shell {
      position: relative;
      z-index: 1;
      width: min(1400px, 100%);
      display: grid;
      gap: 20px;
      grid-template-columns: 1fr 280px;
      grid-template-rows: auto auto auto;
    }

    .main-content {
      grid-column: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .move-history {
      grid-column: 2;
      grid-row: 1 / 4;
      background: var(--panel-strong);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: calc(100vh - 64px);
      overflow-y: auto;
      align-self: start;
      position: sticky;
      top: 32px;
    }

    .history-header {
      font-weight: 700;
      font-size: 14px;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      color: var(--accent);
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .copy-history-btn {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: var(--text);
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: none;
      letter-spacing: 0.3px;
    }

    .copy-history-btn:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(135, 246, 255, 0.3);
      color: var(--accent);
      transform: translateY(-1px);
    }

    .copy-history-btn:active {
      transform: translateY(0);
    }

    .history-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .history-item {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .history-item:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.15);
      transform: translateX(2px);
    }

    .history-item.active {
      background: rgba(135, 246, 255, 0.12);
      border-color: rgba(135, 246, 255, 0.3);
    }

    .history-move {
      font-weight: 700;
      color: var(--accent);
      font-size: 12px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .copy-move-btn {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--muted);
      padding: 3px 6px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
      opacity: 0.6;
    }

    .copy-move-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(135, 246, 255, 0.3);
      color: var(--accent);
      opacity: 1;
      transform: scale(1.1);
    }

    .copy-move-btn:active {
      transform: scale(0.95);
    }

    .history-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
      background: rgba(255, 255, 255, 0.02);
      padding: 6px;
      border-radius: 8px;
    }

    .history-cell {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.05);
      font-size: 10px;
      font-weight: 700;
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .history-cell.filled {
      background: rgba(135, 246, 255, 0.15);
      border-color: rgba(135, 246, 255, 0.2);
      color: var(--accent);
    }

    .header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .title {
      display: flex;
      align-items: baseline;
      gap: 12px;
    }

    .title h1 {
      margin: 0;
      font-size: clamp(32px, 5vw, 44px);
      letter-spacing: -0.5px;
    }

    .title span {
      padding: 4px 12px;
      border-radius: 999px;
      background: rgba(140, 241, 208, 0.12);
      color: var(--accent);
      font-size: 14px;
      letter-spacing: 0.4px;
      text-transform: uppercase;
    }

    .stats {
      display: flex;
      gap: 12px;
    }

    .stat {
      background: var(--panel);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      padding: 10px 14px;
      min-width: 110px;
      text-align: center;
    }

    .stat label {
      display: block;
      color: var(--muted);
      font-size: 13px;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .stat .value {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      border: none;
      color: #04101f;
      font-weight: 700;
      cursor: pointer;
      padding: 12px 18px;
      border-radius: 12px;
      transition: transform 0.1s ease, box-shadow 0.2s ease, background 0.2s ease;
      background: linear-gradient(120deg, var(--accent-strong), #c4ffd1);
      box-shadow: 0 10px 30px rgba(140, 241, 208, 0.35);
    }

    button.ghost {
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      box-shadow: none;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 36px rgba(140, 241, 208, 0.45);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 6px 14px rgba(140, 241, 208, 0.35);
    }

    .play-area {
      background: var(--panel-strong);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 18px;
      position: relative;
      overflow: hidden;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(4, var(--cell-size));
      grid-template-rows: repeat(4, var(--cell-size));
      justify-content: center;
      gap: 12px;
      background: rgba(255, 255, 255, 0.04);
      border-radius: 16px;
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .cell {
      position: relative;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 14px;
      width: var(--cell-size);
      height: var(--cell-size);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(20px, 3vw, 32px);
      font-weight: 800;
      color: #0a0f1c;
      overflow: hidden;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
      transition: transform 0.1s ease, background 0.2s ease, color 0.2s ease;
    }

    .cell.filled {
      box-shadow: var(--tile-shadow);
    }

    .cell::after {
      content: "";
      position: absolute;
      inset: 0;
      opacity: 0;
      transition: opacity 0.2s ease;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.35), transparent 55%);
    }

    .cell.filled::after {
      opacity: 1;
    }

    .tile-2 { background: var(--tile-2-bg); color: var(--tile-2-text); }
    .tile-4 { background: var(--tile-4-bg); color: var(--tile-4-text); }
    .tile-8 { background: var(--tile-8-bg); color: var(--tile-8-text); }
    .tile-16 { background: var(--tile-16-bg); color: var(--tile-16-text); }
    .tile-32 { background: var(--tile-32-bg); color: var(--tile-32-text); }
    .tile-64 { background: var(--tile-64-bg); color: var(--tile-64-text); }
    .tile-128 { background: var(--tile-128-bg); color: var(--tile-128-text); }
    .tile-256 { background: var(--tile-256-bg); color: var(--tile-256-text); }
    .tile-512 { background: var(--tile-512-bg); color: var(--tile-512-text); }
    .tile-1024 { background: var(--tile-1024-bg); color: var(--tile-1024-text); }
    .tile-2048 { background: var(--tile-2048-bg); color: var(--tile-2048-text); }
    .tile-4096, .tile-8192, .tile-16384 { background: var(--tile-4096-bg); color: var(--tile-4096-text); }

    .message {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(5, 9, 18, 0.76);
      backdrop-filter: blur(6px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    .message.show {
      opacity: 1;
      pointer-events: auto;
    }

    .message-box {
      text-align: center;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 26px 30px;
      border-radius: 16px;
      box-shadow: 0 16px 50px rgba(0, 0, 0, 0.4);
    }

    .message-box h2 {
      margin: 0 0 12px;
      font-size: 28px;
      letter-spacing: -0.2px;
    }

    .message-box p {
      margin: 0 0 20px;
      color: var(--muted);
      font-size: 15px;
    }

    .info {
      background: var(--panel);
      border-radius: 14px;
      padding: 14px 16px;
      color: var(--muted);
      line-height: 1.6;
      border: 1px solid rgba(255, 255, 255, 0.05);
      transition: color 0.2s ease;
    }

    .info strong {
      color: var(--text);
    }

    .keys {
      display: inline-flex;
      gap: 8px;
      background: rgba(255, 255, 255, 0.04);
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 28px;
      padding: 6px 10px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.3px;
    }

    @media (max-width: 720px) {
      body {
        padding: 20px;
      }

      .header {
        gap: 16px;
      }

      .stats {
        width: 100%;
      }

      .stat {
        flex: 1;
      }

      .shell {
        grid-template-columns: 1fr;
      }

      .move-history {
        grid-column: 1;
        grid-row: auto;
        max-height: 300px;
      }

      .main-content {
        grid-column: 1;
      }

    }
  </style>
</head>
<body>
  <div class="glow" aria-hidden="true"></div>
  <main class="shell">
    <div class="main-content">
      <div class="header">
        <div class="title">
          <h1>2048</h1>
          <span>Aurora Edition</span>
        </div>
        <div class="stats">
          <div class="stat">
            <label>Score</label>
            <div class="value" id="score">0</div>
          </div>
          <div class="stat">
            <label>Best</label>
            <div class="value" id="best">0</div>
          </div>
        </div>
        <div class="controls">
          <button class="ghost" id="undo">Undo</button>
          <button class="ghost" id="theme-toggle">Theme: Aurora</button>
          <button class="ghost" id="mute-toggle">Sound: On</button>
          <select id="ai-strategy" class="ghost" style="padding: 8px 12px; background: transparent; color: var(--text); border: 1px solid var(--accent); border-radius: 8px; cursor: pointer; font-size: 14px;">
            <option value="expectimax">Expectimax (Best)</option>
            <option value="montecarlo">Monte Carlo</option>
            <option value="weighted">Weighted Heuristic</option>
            <option value="llm">LLM (GPT/DeepSeek)</option>
          </select>
          <select id="ai-model" class="ghost" style="padding: 8px 12px; background: transparent; color: var(--text); border: 1px solid var(--accent); border-radius: 8px; cursor: pointer; font-size: 14px; display: none;">
            <option value="gpt-5.2">Azure GPT-5.2</option>
            <option value="gpt-5.2-chat">Azure GPT-5.2-Chat</option>
            <option value="DeepSeek-V3.2">Azure DeepSeek-V3.2</option>
            <option value="openai-gpt-5.2">OpenAI GPT-5.2</option>
          </select>
          <div id="skills-toggle-container" style="display: none; align-items: center; gap: 8px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 14px; cursor: pointer; color: var(--text);">
              <input type="checkbox" id="enable-skills" checked style="cursor: pointer;">
              <span>ğŸ§  Skills</span>
            </label>
          </div>
          <button class="ghost" id="ask-ai">Ask AI</button>
          <button class="ghost" id="ai-play">AI Play</button>
          <button class="ghost" id="learn-strategy">ğŸ“š Learn Strategy</button>
          <button class="ghost" id="learn-from-collection">ğŸ“š Learn from All Games</button>
          <button class="ghost" id="clear-strategy">ğŸ—‘ï¸ Clear Strategy</button>
          <button id="new-game">New Game</button>
          <input type="file" id="import-histories" multiple accept=".json" style="display: none;">
        </div>
      </div>

      <section class="play-area" aria-live="polite">
        <div class="grid" id="grid"></div>
        <div class="message" id="message">
          <div class="message-box">
            <h2 id="message-title">You Win!</h2>
            <p id="message-text">Keep going to chase a higher tile.</p>
            <button id="continue">Keep Playing</button>
          </div>
        </div>
      </section>

      <section class="info">
        Use the <span class="keys"><span class="key">â†‘</span><span class="key">â†“</span><span class="key">â†</span><span class="key">â†’</span></span> keys or swipe to slide the tiles. Matching tiles merge and add to your score. Chase 2048â€”or keep stacking for a new personal best. Tap Undo or hit U/Cmd+Z to rewind one move. Use Theme to swap palettes and Sound to mute.
      </section>

      <div class="info" id="ai-status">AI ready. Click "Ask AI" to get a suggested move from GPT-5.2 (or the local heuristic fallback).</div>
      <div class="info" id="skills-status" style="display: none; border-color: rgba(255, 177, 227, 0.3); background: rgba(255, 177, 227, 0.05);">
        <strong>ğŸ§  GPT-5.2 Skills Active:</strong> <span id="skills-active-list"></span>
      </div>
      <div class="info" id="strategy-result" style="display: none; border-color: rgba(135, 246, 255, 0.3); background: rgba(135, 246, 255, 0.05);"></div>
      <div class="info" id="learned-note-container" style="display: none;">
        <label style="display: block; margin-bottom: 6px; font-weight: bold;">ğŸ“ Learned Strategy Prompt (sent to AI):</label>
        <textarea id="learned-note" readonly rows="8" style="width: 100%; background: rgba(0,0,0,0.3); color: var(--text); border: 1px solid var(--accent); border-radius: 8px; padding: 10px; font-family: monospace; font-size: 12px; resize: vertical;"></textarea>
      </div>
      <div class="info" id="game-collection-panel" style="border-color: rgba(255, 177, 227, 0.3); background: rgba(255, 177, 227, 0.05);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <label style="font-weight: bold;">ğŸ“¦ Game Collection</label>
          <div style="display: flex; gap: 8px;">
            <button class="ghost" id="import-btn" style="padding: 6px 12px; font-size: 12px;">ğŸ“¥ Import JSON</button>
            <button class="ghost" id="clear-collection" style="padding: 6px 12px; font-size: 12px;">ğŸ—‘ï¸ Clear All</button>
          </div>
        </div>
        <div id="collection-stats" style="font-size: 13px; color: var(--muted);">No games saved yet. Complete games to build your collection.</div>
        <div id="collection-list" style="margin-top: 10px; max-height: 150px; overflow-y: auto;"></div>
      </div>
    </div>

    <section class="move-history">
      <div class="history-header">
        <span>Move History</span>
        <div style="display: flex; gap: 8px;">
          <button class="copy-history-btn" id="copy-history" title="Copy to clipboard">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
          </button>
          <button class="copy-history-btn" id="download-history" title="Download as JSON">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
          </button>
          <button class="copy-history-btn" id="load-history" title="Load from JSON file">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="17 8 12 3 7 8"></polyline>
              <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
          </button>
          <input type="file" id="load-history-input" accept=".json" style="display: none;">
        </div>
      </div>
      <div class="history-list" id="history-list"></div>
    </section>
  </main>

  <script>
    const size = 4;
    let board = [];
    let score = 0;
    let best = 0;
    let acceptInput = true;
    let history = [];
    const historyLimit = 32;
    let audioCtx = null;
    let muted = false;
    let theme = 'aurora';
    let aiThinking = false;
    let aiPlaying = false;
    let learnedStrategy = null;
    let selectedModel = 'gpt-5.2';
    let gameCollection = [];
    const gameCollectionStorageKey = 'aurora-2048-games-collection';

    const aiModels = {
      'gpt-5.2': {
        endpoint: 'https://maritimeai-resource.openai.azure.com',
        deployment: 'gpt-5.2',
        apiVersion: '2025-03-01-preview',
        type: 'azure'
      },
      'gpt-5.2-chat': {
        endpoint: 'https://maritimeai-resource.openai.azure.com',
        deployment: 'gpt-5.2-chat',
        apiVersion: '2025-03-01-preview',
        type: 'azure'
      },
      'DeepSeek-V3.2': {
        endpoint: 'https://maritimeai-resource.openai.azure.com',
        deployment: 'DeepSeek-V3.2',
        apiVersion: '2025-03-01-preview',
        type: 'azure'
      },
      'openai-gpt-5.2': {
        endpoint: 'https://api.bianxie.ai',
        model: 'gpt-5.2',
        type: 'openai'
      }
    };

    const azureAI = {
      endpoint: 'https://maritimeai-resource.openai.azure.com',
      apiKey: '',
      deployment: 'gpt-5.2',
      apiVersion: '2025-03-01-preview'
    };
    const apiKeyStorageKey = 'aurora-2048-azure-key';
    const openaiApiKeyStorageKey = 'aurora-2048-openai-key';
    const modelStorageKey = 'aurora-2048-ai-model';

    // GPT-5.2 Skills Configuration
    // Azure OpenAI: only function calling and structured outputs
    // OpenAI: full skills including code_interpreter
    const gpt52SkillsAzure = {
      codeInterpreter: false,  // Not supported by Azure OpenAI
      structuredOutputs: true,  // Supported via response_format
      functionCalling: true,    // Supported via functions parameter
      reasoning: true           // Enhanced prompts for better reasoning
    };
    
    const gpt52SkillsOpenAI = {
      codeInterpreter: true,   // âœ“ Supported by OpenAI
      structuredOutputs: true,  // âœ“ Supported by OpenAI
      functionCalling: true,    // âœ“ Supported by OpenAI
      reasoning: true           // Enhanced prompts for better reasoning
    };
    
    let openaiApiKey = '';

    let skillsEnabled = true; // Default: enabled for GPT-5.2
    const skillsStorageKey = 'aurora-2048-skills-enabled';

    // Structured Output Schema for GPT-5.2
    const moveDecisionSchema = {
      type: "json_schema",
      json_schema: {
        name: "move_decision",
        strict: true,
        schema: {
          type: "object",
          properties: {
            reasoning: {
              type: "string",
              description: "Step-by-step analysis of current board state"
            },
            board_analysis: {
              type: "object",
              properties: {
                max_tile: { type: "number" },
                max_tile_position: { type: "string" },
                empty_cells: { type: "number" },
                monotonicity_score: { type: "number" },
                anchor_safe: { type: "boolean" }
              },
              required: ["max_tile", "max_tile_position", "empty_cells", "monotonicity_score", "anchor_safe"],
              additionalProperties: false
            },
            move_evaluations: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  move: { 
                    type: "string",
                    enum: ["up", "down", "left", "right"]
                  },
                  score: { type: "number" },
                  is_valid: { type: "boolean" },
                  reason: { type: "string" }
                },
                required: ["move", "score", "is_valid", "reason"],
                additionalProperties: false
              }
            },
            recommended_move: {
              type: "string",
              enum: ["up", "down", "left", "right"]
            },
            confidence: {
              type: "number",
              minimum: 0,
              maximum: 1
            }
          },
          required: ["reasoning", "board_analysis", "move_evaluations", "recommended_move", "confidence"],
          additionalProperties: false
        }
      }
    };

    // Game Functions for GPT-5.2 Function Calling
    const gameFunctions = [
      {
        name: "evaluate_board",
        description: "Evaluate board state using multiple heuristics including monotonicity, smoothness, empty cells, and corner anchoring. Returns a composite score.",
        parameters: {
          type: "object",
          properties: {
            board: {
              type: "array",
              items: {
                type: "array",
                items: { type: "number" }
              },
              description: "4x4 board as 2D array"
            }
          },
          required: ["board"]
        }
      },
      {
        name: "simulate_moves",
        description: "Simulate all 4 possible moves (up, down, left, right) and return outcomes including whether moves are valid, score gains, and merge occurrences.",
        parameters: {
          type: "object",
          properties: {
            board: {
              type: "array",
              items: {
                type: "array",
                items: { type: "number" }
              },
              description: "Current 4x4 board state"
            }
          },
          required: ["board"]
        }
      },
      {
        name: "check_anchor_safety",
        description: "Check if a proposed move would displace the maximum tile from the top-right corner (anchor position).",
        parameters: {
          type: "object",
          properties: {
            board: {
              type: "array",
              items: {
                type: "array",
                items: { type: "number" }
              },
              description: "Current 4x4 board state"
            },
            move: {
              type: "string",
              enum: ["up", "down", "left", "right"],
              description: "The move to check"
            }
          },
          required: ["board", "move"]
        }
      }
    ];

    const coreStrategyPrompt1 = `æ ¸å¿ƒç­–ç•¥ - æŒ‰ä¼˜å…ˆçº§åº”ç”¨è¿™äº›ç»è¿‡éªŒè¯çš„åŸåˆ™ï¼š

1. å•è°ƒæ€§ï¼ˆå¿…è¦ï¼‰ï¼šä¿æŒè¡Œå’Œåˆ—åœ¨ä¸€ä¸ªæ–¹å‘ä¸Šå•è°ƒé€’å‡ã€‚
   - å³ä¸Šé”šå®š + è›‡å½¢åˆ†å¸ƒã€‚
   - é¡¶è¡Œä»å³åˆ°å·¦é€’å‡ï¼Œå³åˆ—ä»ä¸Šåˆ°ä¸‹é€’å‡ã€‚
   - ç¦æ­¢å‡ºç°ä¸­é—´æ¯”è§’è½æ›´å¤§çš„æ–­å±‚ã€‚

2. è§’è½é”šå®šï¼ˆå…³é”®ï¼‰ï¼šæœ€å¤§æ–¹å—å¿…é¡»ç¨³å®šåœ¨å³ä¸Šè§’ã€‚
   - ä»»æ„ç§»åŠ¨å¦‚æœä¼šæŠŠæœ€å¤§æ–¹å—ä»å³ä¸Šè§’æ‹‰èµ°ï¼Œç›´æ¥å¦å†³ã€‚
   - ä¿®å¤è§’è½é€šå¸¸æˆæœ¬å¾ˆé«˜ï¼Œä¼˜å…ˆé¿å…ç ´åã€‚

3. å¹³æ»‘æ€§ï¼ˆé‡è¦ï¼‰ï¼š
   - å°½é‡å‡å°‘è·³è·ƒå·®å€¼
   - ç›¸è¿‘æ•°å€¼ä¿æŒé‚»è¿‘ï¼Œæ”¯æŒè‡ªç„¶åˆå¹¶ã€‚

4. åˆå¹¶æœºä¼šï¼ˆé‡è¦ï¼‰ï¼š
   - åªåšâ€œç»“æ„å®‰å…¨â€çš„åˆå¹¶ï¼š
     â€” ä¸ç ´åå•è°ƒæ€§
     â€” ä¸æ¨å¼€è§’è½
     â€” ä¸æ‹†æ•£ä¸»é“¾ (8â†’16â†’32â†’64â†’128)

5. è‡ªç”±ç©ºé—´ï¼ˆé‡è¦ï¼‰ï¼š
   - ç›®æ ‡ä¿æŒ â‰¥ 4 ç©ºä½
   - ç©ºé—´ç´§å¼ æ—¶ä¼˜å…ˆåˆ›é€ ç©ºé—´ï¼Œè€Œéå¾—åˆ†

6. é“¾å¼åˆå¹¶ï¼ˆå…³é”®ï¼‰ï¼š
   - å½“ç§»åŠ¨å¯ä»¥åˆ›é€ è¿ç»­åˆå¹¶è·¯çº¿æ—¶ä¼˜å…ˆï¼š
     â€” èšæ‹¢ä¸¤ä¸ªç›¸åŒè¾ƒå¤§æ•°
     â€” åç»­èƒ½æ¥å…¥æ›´å¤§çš„ä¸»é“¾
     â€” å‰ææ˜¯ä¸ç ´åè§’è½å’Œé¡¶è¡Œ

7. çºµå‘èšæ‹¢ï¼š
   - è‹¥ UP å¯ä»¥æŠŠå°å—é€å…¥ä¸»é“¾ï¼ˆé¡¶è¡Œ/å³åˆ—ï¼‰ä¸”ä¸ç ´åç»“æ„ï¼Œåˆ™ä¼˜å…ˆã€‚
   - ç”¨äºæŠŠ 2/4/8 çº³å…¥å¢é•¿è·¯å¾„ã€‚

8. ç»“æ„é¢„é˜²ï¼ˆæ–°å¢ï¼‰ï¼š
   - å°½é‡é¿å…æ•´åˆ—æˆ–æ•´è¡Œåœ¨éä¸»é“¾æ–¹å‘è¢«å®Œå…¨å¡«æ»¡ã€‚
   - å§‹ç»ˆåœ¨å·¦ä¾§æˆ–ä¸­éƒ¨ä¿ç•™â€œæ”¯ç‚¹â€ï¼Œä»¥ä¾¿éœ€è¦æ—¶å¯ä»¥ UP æˆ– RIGHT è°ƒæ•´ã€‚

9. å‘ä¸‹ç§»åŠ¨çš„æœ‰é™ä¾‹å¤–ï¼ˆæ–°å¢ï¼Œéå¸¸é‡è¦ï¼‰ï¼š
   - ä»¥ä¸‹æƒ…å½¢å…è®¸ DOWNï¼Œç”šè‡³ä¼˜å…ˆï¼š
     â€” å³åˆ—å·²æ»¡ï¼Œä¸”æœ€å¤§å—ä»åœ¨å³ä¸Šè§’
     â€” DOWN ä¸ä¼šç§»åŠ¨æœ€å¤§å—
     â€” DOWN å¯åœ¨å³åˆ—å½¢æˆåˆå¹¶æˆ–èšæ‹¢
     â€” DOWN å¯ä»¥åœ¨é¡¶éƒ¨åˆ›é€ æ–°ç©ºé—´
   - å¦‚æœ DOWN åªæ˜¯å•çº¯æŒ¤å‹ï¼Œæ²¡æœ‰ç»“æ„æ”¶ç›Šï¼Œåˆ™ç¦æ­¢ã€‚

ç§»åŠ¨æŒ‡å—ï¼š
- ç¬¬ä¸€ä¼˜å…ˆï¼šå³ï¼ˆç¨³å›ºé¡¶è¡Œä¸è§’è½ï¼‰
- ç¬¬äºŒä¼˜å…ˆï¼šä¸Šï¼ˆå»¶é•¿ä¸»é“¾ã€èšæ‹¢èµ„æºï¼‰
- å·¦ï¼šä»…åœ¨æ»¡è¶³ä¸¥æ ¼æ¡ä»¶ä¸”å¯åœ¨ 1â€“2 æ­¥å†…æ¢å¤ç»“æ„æ—¶ä½¿ç”¨
- ä¸‹ï¼šä»…åœ¨â€œæœ‰é™ä¾‹å¤–æ¡ä»¶â€æ»¡è¶³æ—¶ä½¿ç”¨ï¼ˆè§è§„åˆ™ 9ï¼‰

å†³ç­–è¿‡ç¨‹ï¼š
1. æ˜¯å¦ä¼šè®©æœ€å¤§æ–¹å—ç¦»å¼€å³ä¸Šè§’ï¼Ÿï¼ˆæ˜¯ â†’ å¦å†³ï¼‰
2. æ˜¯å¦ç ´åé¡¶è¡Œæˆ–å³åˆ—çš„å•è°ƒæ€§ï¼Ÿ
3. æ˜¯å¦å¸¦æ¥ç»“æ„æ€§æ”¶ç›Šï¼ˆé“¾å¼åˆå¹¶ / èšæ‹¢ / åˆ›é€ ç©ºé—´ï¼‰ï¼Ÿ
4. æ˜¯å¦ä¿æŒè¶³å¤Ÿç©ºç™½æ ¼ï¼Ÿ
5. ä¸¤æ­¥ä¹‹åæ˜¯å¦ä»ç„¶å®‰å…¨ï¼Ÿ
6. è‹¥è€ƒè™‘ DOWNï¼šæ˜¯å¦ç¬¦åˆâ€œæœ‰é™ä¾‹å¤–æ¡ä»¶â€ï¼Ÿ`;

    const coreStrategyPrompt = 'è¿™ä¸ªæ¸¸æˆæ˜¯é€šè¿‡ç§»åŠ¨æ–¹å—æ¥å®ç°æœ€ç»ˆå®Œæˆ2048è¿™ä¸ªæ•°å­—çš„ç»„åˆã€‚åˆå§‹é˜¶æ®µï¼Œä¸æ–­çš„ä½¿ç”¨å‘ä¸Šï¼Œå’Œå‘å³çš„æ–¹å‘ã€‚æŒ‰ç…§1-16çš„æ–¹æ³•æ¥å®šä¹‰æ ¼å­æ•°ï¼Œç¼–å·ç¬¬ä¸€æ’æŒ‰ä»å·¦å‘å³åˆ†åˆ«æ˜¯1åˆ°4ï¼Œç¬¬äºŒæ’5-8ï¼Œç¬¬ä¸‰æ’9-12ï¼Œç¬¬å››æ’13-16ã€‚æ¸¸æˆè¿‡ç¨‹ä¸­ï¼Œå§‹ç»ˆä¿æŒå³ä¸Šè§’ï¼Œå³ç¬¬4å—æ ¼å­çš„æ•°å­—æœ€å¤§ï¼Œå°½é‡ä¿è¯ç¬¬3å—æ ¼å­ç¬¬äºŒå¤§ï¼Œç¬¬2å—æ ¼å­ç¬¬ä¸‰å¤§ï¼Œç¬¬1å—æ ¼å­ç¬¬å››å¤§ã€‚åœ¨æ¸¸æˆè¿‡ç¨‹ä¸­ï¼Œå¦‚æœé‡åˆ°éœ€è¦è°ƒæ•´ç¬¬å››å—æ ¼å­çš„æƒ…å†µï¼Œé‚£ä¹ˆä¿è¯ç§»åŠ¨æœ€å°‘çš„æ­¥æ•°ï¼Œå¹¶ä¸”å¦‚æœç¬¬4æ ¼æ²¡æœ‰äº§ç”Ÿæ–°çš„æ–¹å—ï¼Œéœ€é©¬ä¸Šå°†è°ƒèµ°çš„ç¬¬4å—æ–¹æ ¼è°ƒå›å»ï¼Œå¦‚æœè°ƒä¸å›å»ï¼Œåˆ™å°½é‡ä¿æŒåœ¨åå³ä¸Šçš„ä½ç½®ã€‚ç©åˆ°åæœŸï¼Œå¦‚æœé‡åˆ°64,128è¿™ç§æ•°å­—åœ¨å·¦ä¸‹åŒºåŸŸï¼Œåˆ™å°½é‡è°ƒæ•´å…¶ä½ç½®åˆ°å³ä¸Šæ–¹ï¼Œä¾¿äºåˆæˆæ›´å¤§çš„æ•°å­—ã€‚';

    const gridEl = document.getElementById('grid');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const messageEl = document.getElementById('message');
    const messageTitle = document.getElementById('message-title');
    const messageText = document.getElementById('message-text');
    const continueBtn = document.getElementById('continue');
    const newGameBtn = document.getElementById('new-game');
    const undoBtn = document.getElementById('undo');
    const themeToggleBtn = document.getElementById('theme-toggle');
    const muteToggleBtn = document.getElementById('mute-toggle');
    const askAiBtn = document.getElementById('ask-ai');
    const aiPlayBtn = document.getElementById('ai-play');
    const aiStatusEl = document.getElementById('ai-status');
    const historyListEl = document.getElementById('history-list');
    const strategyResultEl = document.getElementById('strategy-result');
    const learnStrategyBtn = document.getElementById('learn-strategy');
    const clearStrategyBtn = document.getElementById('clear-strategy');
    const learnedNoteContainer = document.getElementById('learned-note-container');
    const learnedNoteEl = document.getElementById('learned-note');
    const aiModelSelect = document.getElementById('ai-model');
    const aiStrategySelect = document.getElementById('ai-strategy');
    const copyHistoryBtn = document.getElementById('copy-history');
    const cells = [];
    let moveHistory = [];

    function init() {
      createGrid();
      best = Number.parseInt(localStorage.getItem('aurora-2048-best') || '0', 10);
      bestEl.textContent = best;
      const storedTheme = localStorage.getItem('aurora-2048-theme');
      if (storedTheme === 'dawn' || storedTheme === 'aurora') theme = storedTheme;
      applyTheme(theme);
      muted = localStorage.getItem('aurora-2048-muted') === '1';
      updateToggles();
      loadApiKey();
      loadSelectedStrategy();
      loadSelectedModel();
      loadLearnedStrategy();
      loadGameCollection();
      if (!loadGameState()) {
        newGame();
      }
      setupInput();
    }

    function createGrid() {
      for (let i = 0; i < size * size; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell tile';
        cells.push(cell);
        gridEl.appendChild(cell);
      }
    }

    function newGame() {
      board = Array.from({ length: size }, () => Array(size).fill(0));
      score = 0;
      acceptInput = true;
      history = [];
      moveHistory = [];
      hideMessage();
      addRandomTile();
      addRandomTile();
      updateUI();
      renderMoveHistory();
      saveGameState();
    }

    function addRandomTile() {
      const empty = [];
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (board[r][c] === 0) empty.push([r, c]);
        }
      }
      if (!empty.length) return;
      const [r, c] = empty[Math.floor(Math.random() * empty.length)];
      board[r][c] = Math.random() < 0.9 ? 2 : 4;
    }

    function move(direction) {
      if (!acceptInput) return;
      let moved = false;
      let mergedDuringMove = false;
      const snapshot = snapshotState();

      // Record the board state BEFORE the move with the direction to be applied
      const boardBeforeMove = board.map(row => row.slice());

      const operate = direction === 'left' || direction === 'right' ? moveHorizontal : moveVertical;
      const { moved: didMove, merged } = operate(direction);
      moved = didMove;
      mergedDuringMove = merged;

      if (moved) {
        pushHistory(snapshot);
        addRandomTile();
        recordMoveToHistory(direction, boardBeforeMove);
        updateUI();
        playSound(mergedDuringMove ? 'merge' : 'move');
        renderMoveHistory();
        saveGameState();
        // if (has2048()) showMessage('You reached 2048!', 'Keep going or start fresh.');
        if (isGameOver()) {
          saveGameToCollection();
          showMessage('No moves left', 'Try again and push the high score.');
        }
      }
    }

    function moveHorizontal(direction) {
      let moved = false;
      let merged = false;
      for (let r = 0; r < size; r++) {
        const row = board[r].slice();
        const processed = processLine(direction === 'left' ? row : row.slice().reverse());
        const newRow = direction === 'left' ? processed.line : processed.line.slice().reverse();
        merged = merged || processed.merged;
        if (!arraysEqual(board[r], newRow)) {
          board[r] = newRow;
          moved = true;
        }
      }
      return { moved, merged };
    }

    function moveVertical(direction) {
      let moved = false;
      let merged = false;
      for (let c = 0; c < size; c++) {
        const col = board.map(row => row[c]);
        const processed = processLine(direction === 'up' ? col : col.slice().reverse());
        const newCol = direction === 'up' ? processed.line : processed.line.slice().reverse();
        merged = merged || processed.merged;
        if (!arraysEqual(col, newCol)) {
          for (let r = 0; r < size; r++) board[r][c] = newCol[r];
          moved = true;
        }
      }
      return { moved, merged };
    }

    function processLine(line) {
      const compact = line.filter(n => n !== 0);
      let merged = false;
      for (let i = 0; i < compact.length - 1; i++) {
        if (compact[i] === compact[i + 1]) {
          compact[i] *= 2;
          score += compact[i];
          compact.splice(i + 1, 1);
          merged = true;
        }
      }
      while (compact.length < size) compact.push(0);
      return { line: compact, merged };
    }

    function arraysEqual(a, b) {
      return a.length === b.length && a.every((val, i) => val === b[i]);
    }

    function has2048() {
      return board.some(row => row.some(cell => cell === 2048));
    }

    function isGameOver() {
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const current = board[r][c];
          if (current === 0) return false;
          if (c < size - 1 && current === board[r][c + 1]) return false;
          if (r < size - 1 && current === board[r + 1][c]) return false;
        }
      }
      return true;
    }

    function updateUI() {
      best = Math.max(best, score);
      localStorage.setItem('aurora-2048-best', best);
      scoreEl.textContent = score;
      bestEl.textContent = best;

      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const value = board[r][c];
          const idx = r * size + c;
          const cell = cells[idx];
          cell.textContent = value || '';
          cell.dataset.value = value || '';
          cell.className = 'cell tile';
          if (value) {
            cell.classList.add('filled', `tile-${value <= 4096 ? value : 4096}`);
            cell.style.transform = 'scale(1.02)';
            requestAnimationFrame(() => {
              cell.style.transform = 'scale(1)';
            });
          }
        }
      }
    }

    function updateToggles() {
      themeToggleBtn.textContent = `Theme: ${theme === 'aurora' ? 'Aurora' : 'Dawn'}`;
      muteToggleBtn.textContent = `Sound: ${muted ? 'Off' : 'On'}`;
    }

    function applyTheme(name) {
      const next = name === 'dawn' ? 'dawn' : 'aurora';
      document.body.classList.remove('theme-aurora', 'theme-dawn');
      document.body.classList.add(`theme-${next}`);
      theme = next;
      localStorage.setItem('aurora-2048-theme', next);
      updateToggles();
    }

    function toggleTheme() {
      applyTheme(theme === 'aurora' ? 'dawn' : 'aurora');
    }

    function setAiStatus(text) {
      aiStatusEl.innerHTML = text;
    }

    function promptForApiKey() {
      const model = aiModels[selectedModel];
      if (model.type === 'openai') {
        const input = window.prompt('Enter your OpenAI API key (stored locally in this browser):', '');
        if (input && input.trim()) {
          openaiApiKey = input.trim();
          localStorage.setItem(openaiApiKeyStorageKey, openaiApiKey);
          setAiStatus('OpenAI API key saved locally. GPT-5.2 will be used.');
        } else {
          setAiStatus('No API key set; AI uses fallback heuristic until you add a key.');
        }
      } else {
        const input = window.prompt('Enter your Azure OpenAI API key (stored locally in this browser):', '');
        if (input && input.trim()) {
          azureAI.apiKey = input.trim();
          localStorage.setItem(apiKeyStorageKey, azureAI.apiKey);
          setAiStatus('Azure API key saved locally. GPT-5.2 will be used when configured.');
        } else {
          setAiStatus('No API key set; AI uses fallback heuristic until you add a key.');
        }
      }
    }

    function loadApiKey() {
      // Load Azure API key
      const azureSaved = localStorage.getItem(apiKeyStorageKey);
      if (azureSaved) {
        azureAI.apiKey = azureSaved;
      }
      
      // Load OpenAI API key
      const openaiSaved = localStorage.getItem(openaiApiKeyStorageKey);
      if (openaiSaved) {
        openaiApiKey = openaiSaved;
      }
      
      // Prompt for key based on current model selection
      const model = aiModels[selectedModel];
      if (model.type === 'openai' && !openaiApiKey) {
        setAiStatus('OpenAI API key needed for full skills support.');
        promptForApiKey();
      } else if (model.type === 'azure' && !azureAI.apiKey) {
        setAiStatus('Azure API key loaded or ready to configure.');
        promptForApiKey();
      } else {
        setAiStatus('API keys loaded from local storage.');
      }
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function snapshotState() {
      return {
        board: board.map(row => row.slice()),
        score
      };
    }

    function pushHistory(state) {
      history.push(state);
      if (history.length > historyLimit) history.shift();
    }

    function undo() {
      if (!history.length) return;
      const prev = history.pop();
      board = prev.board.map(row => row.slice());
      score = prev.score;
      hideMessage();
      acceptInput = true;
      if (moveHistory.length > 0) {
        moveHistory.pop();
      }
      updateUI();
      renderMoveHistory();
      saveGameState();
    }

    function ensureAudio() {
      if (muted) return;
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playSound(type) {
      if (muted) return;
      ensureAudio();
      const ctx = audioCtx;
      if (!ctx) return;
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      const isMerge = type === 'merge';
      const freq = isMerge ? 420 : 220;
      const duration = isMerge ? 0.18 : 0.12;

      osc.type = isMerge ? 'triangle' : 'sine';
      osc.frequency.setValueAtTime(freq, now);

      gain.gain.setValueAtTime(isMerge ? 0.16 : 0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

      osc.connect(gain).connect(ctx.destination);
      osc.start(now);
      osc.stop(now + duration);
    }

    function toggleMute() {
      muted = !muted;
      localStorage.setItem('aurora-2048-muted', muted ? '1' : '0');
      updateToggles();
      if (!muted) ensureAudio();
    }

    function formatBoardForAI() {
      return board.map(row => row.join(' ')).join('\n');
    }

    // Function Handlers for GPT-5.2 Function Calling
    function handleFunctionCall(functionName, args) {
      switch(functionName) {
        case 'evaluate_board':
          return evaluateBoardFunction(args.board);
        case 'simulate_moves':
          return simulateMovesFunction(args.board);
        case 'check_anchor_safety':
          return checkAnchorSafetyFunction(args.board, args.move);
        default:
          return { error: 'Unknown function' };
      }
    }

    function evaluateBoardFunction(boardState) {
      const score = evaluateBoardExpectimax(boardState);
      const maxTile = Math.max(...boardState.flat());
      const empties = boardState.flat().filter(n => n === 0).length;
      const mono = calculateMonotonicity(boardState);
      const smooth = calculateSmoothness(boardState);
      
      return {
        total_score: score,
        max_tile: maxTile,
        empty_cells: empties,
        monotonicity: mono,
        smoothness: smooth,
        anchor_safe: boardState[0][3] === maxTile
      };
    }

    function simulateMovesFunction(boardState) {
      const directions = ['up', 'down', 'left', 'right'];
      const results = {};
      
      for (const dir of directions) {
        const result = simulateMove(boardState, dir);
        const evaluation = result.moved ? evaluateBoardExpectimax(result.nextState) : -Infinity;
        
        results[dir] = {
          is_valid: result.moved,
          merged: result.merged,
          score_gain: result.gain,
          evaluation_score: evaluation,
          empty_cells_after: result.moved ? result.nextState.flat().filter(n => n === 0).length : 0
        };
      }
      
      return results;
    }

    function checkAnchorSafetyFunction(boardState, move) {
      const maxTile = Math.max(...boardState.flat());
      const isAnchored = boardState[0][3] === maxTile;
      
      if (!isAnchored) {
        return {
          currently_anchored: false,
          move_safe: true,
          reason: "Max tile not at anchor, any move allowed"
        };
      }
      
      const result = simulateMove(boardState, move);
      if (!result.moved) {
        return {
          currently_anchored: true,
          move_safe: false,
          reason: "Move not possible"
        };
      }
      
      const stillAnchored = result.nextState[0][3] === maxTile;
      
      return {
        currently_anchored: true,
        move_safe: stillAnchored,
        reason: stillAnchored ? "Max tile stays at anchor" : "Max tile would be displaced from anchor"
      };
    }

    function simulateMove(state, direction) {
      const temp = state.map(row => row.slice());
      let moved = false;
      let merged = false;
      let gain = 0;

      const processLineSim = (line) => {
        const compact = line.filter(n => n !== 0);
        for (let i = 0; i < compact.length - 1; i++) {
          if (compact[i] === compact[i + 1]) {
            compact[i] *= 2;
            gain += compact[i];
            compact.splice(i + 1, 1);
            merged = true;
          }
        }
        while (compact.length < size) compact.push(0);
        return compact;
      };

      if (direction === 'left' || direction === 'right') {
        for (let r = 0; r < size; r++) {
          const row = temp[r].slice();
          const processed = processLineSim(direction === 'left' ? row : row.slice().reverse());
          const newRow = direction === 'left' ? processed : processed.slice().reverse();
          if (!arraysEqual(temp[r], newRow)) {
            temp[r] = newRow;
            moved = true;
          }
        }
      } else {
        for (let c = 0; c < size; c++) {
          const col = temp.map(row => row[c]);
          const processed = processLineSim(direction === 'up' ? col : col.slice().reverse());
          const newCol = direction === 'up' ? processed : processed.slice().reverse();
          if (!arraysEqual(col, newCol)) {
            for (let r = 0; r < size; r++) temp[r][c] = newCol[r];
            moved = true;
          }
        }
      }

      return { moved, merged, gain, nextState: temp };
    }

    function anchorAtTopRight() {
      const maxVal = Math.max(...board.flat());
      return maxVal > 0 && board[0][size - 1] === maxVal;
    }

    function moveIsPossible(dir) {
      return simulateMove(board, dir).moved;
    }

    function isRightColumnFull() {
      return board.every(row => row[3] !== 0);
    }

    function anchorGuard(direction) {
      // If anchor is not at top-right, allow any move
      if (!anchorAtTopRight()) return direction;
      
      // DOWN is only allowed when right column is completely full
      // and DOWN won't move the max tile
      if (direction === 'down') {
        if (!isRightColumnFull()) {
          // Right column not full - find alternative
          const alternatives = ['up', 'left', 'right'];
          for (const alt of alternatives) {
            if (moveIsPossible(alt)) return alt;
          }
        }
        // Right column is full - allow DOWN
        return direction;
      }
      
      // UP, LEFT, RIGHT are generally safe when anchor is at top-right
      return direction;
    }

    // ========== AI STRATEGY IMPLEMENTATIONS ==========
    
    // Snake pattern weight matrix - higher weights in top-right corner
    const WEIGHT_MATRIX = [
      [Math.pow(4, 15), Math.pow(4, 14), Math.pow(4, 13), Math.pow(4, 12)],
      [Math.pow(4, 8),  Math.pow(4, 9),  Math.pow(4, 10), Math.pow(4, 11)],
      [Math.pow(4, 7),  Math.pow(4, 6),  Math.pow(4, 5),  Math.pow(4, 4)],
      [Math.pow(4, 0),  Math.pow(4, 1),  Math.pow(4, 2),  Math.pow(4, 3)]
    ];

    // Alternative corner-focused weight matrix
    const CORNER_WEIGHTS = [
      [6, 5, 4, 3],
      [5, 4, 3, 2],
      [4, 3, 2, 1],
      [3, 2, 1, 0]
    ].map(row => row.map(w => Math.pow(4, w)));

    // Strategy 1: Weighted Heuristic (Optimized with deeper lookahead)
    function weightedHeuristicMove(boardState) {
      const directions = ['up', 'down', 'left', 'right'];
      let bestMove = null;
      let bestScore = -Infinity;

      for (const dir of directions) {
        const result = simulateMove(boardState, dir);
        if (!result.moved) continue;

        // Use 3-ply minimax lookahead with alpha-beta pruning concept
        const score = minimaxLookahead(result.nextState, 3, -Infinity, Infinity, false);
        if (score > bestScore) {
          bestScore = score;
          bestMove = dir;
        }
      }

      return bestMove || 'up';
    }

    function minimaxLookahead(boardState, depth, alpha, beta, isMaximizing) {
      if (depth === 0) {
        return evaluateBoardExpectimax(boardState); // Use the better evaluation function
      }

      const directions = ['up', 'down', 'left', 'right'];
      
      if (isMaximizing) {
        let maxScore = -Infinity;
        let anyMoved = false;
        
        for (const dir of directions) {
          const result = simulateMove(boardState, dir);
          if (!result.moved) continue;
          anyMoved = true;
          
          const score = minimaxLookahead(result.nextState, depth - 1, alpha, beta, false);
          maxScore = Math.max(maxScore, score);
          alpha = Math.max(alpha, score);
          if (beta <= alpha) break; // Pruning
        }
        
        return anyMoved ? maxScore : evaluateBoardExpectimax(boardState);
      } else {
        // Pessimistic: assume worst-case tile placement
        const empties = [];
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            if (boardState[r][c] === 0) empties.push([r, c]);
          }
        }
        
        if (empties.length === 0) {
          return minimaxLookahead(boardState, depth - 1, alpha, beta, true);
        }
        
        // Sample worst positions (corners are usually worst for new tiles)
        let minScore = Infinity;
        const sampleSize = Math.min(empties.length, 3);
        
        // Prioritize corner/edge positions as worst cases
        const sortedEmpties = empties.sort((a, b) => {
          const aCorner = (a[0] === 0 || a[0] === 3) && (a[1] === 0 || a[1] === 3);
          const bCorner = (b[0] === 0 || b[0] === 3) && (b[1] === 0 || b[1] === 3);
          return bCorner - aCorner;
        });
        
        for (let i = 0; i < sampleSize; i++) {
          const [r, c] = sortedEmpties[i];
          // Test with tile value 4 (worst case)
          const board4 = boardState.map(row => row.slice());
          board4[r][c] = 4;
          const score = minimaxLookahead(board4, depth - 1, alpha, beta, true);
          minScore = Math.min(minScore, score);
          beta = Math.min(beta, score);
          if (beta <= alpha) break;
        }
        
        return minScore;
      }
    }

    function evaluateBoardWeighted(boardState) {
      // Use the same comprehensive evaluation as Expectimax
      return evaluateBoardExpectimax(boardState);
    }

    // Strategy 2: Monte Carlo Tree Search (Optimized)
    function monteCarloMove(boardState, simulations = 150) {
      const directions = ['up', 'down', 'left', 'right'];
      const results = [];

      for (const dir of directions) {
        const result = simulateMove(boardState, dir);
        if (!result.moved) continue;

        let totalScore = 0;
        for (let i = 0; i < simulations; i++) {
          totalScore += runGreedySimulation(result.nextState);
        }
        
        results.push({
          dir,
          avgScore: totalScore / simulations,
          immediateScore: evaluateBoardExpectimax(result.nextState)
        });
      }

      if (results.length === 0) return 'up';
      
      // Combine immediate evaluation with simulation results
      results.sort((a, b) => {
        const scoreA = a.avgScore + a.immediateScore * 0.1;
        const scoreB = b.avgScore + b.immediateScore * 0.1;
        return scoreB - scoreA;
      });
      
      return results[0].dir;
    }

    function runGreedySimulation(startBoard) {
      let simBoard = startBoard.map(row => row.slice());
      let simScore = 0;
      let moves = 0;
      const maxMoves = 150;

      while (moves < maxMoves) {
        // Use greedy best move (fast 1-ply evaluation) instead of random
        const move = selectGreedyMove(simBoard);
        if (!move) break;
        
        const result = simulateMove(simBoard, move);
        if (!result.moved) break;
        
        simBoard = result.nextState;
        simScore += result.gain;
        
        // Add random tile
        const empties = [];
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            if (simBoard[r][c] === 0) empties.push([r, c]);
          }
        }
        
        if (empties.length === 0) break;
        
        const [r, c] = empties[Math.floor(Math.random() * empties.length)];
        simBoard[r][c] = Math.random() < 0.9 ? 2 : 4;
        
        moves++;
      }

      // Use comprehensive evaluation at the end
      return simScore + evaluateBoardExpectimax(simBoard) / 10000;
    }

    function selectGreedyMove(boardState) {
      // Fast greedy selection: pick the move with best immediate evaluation
      // Add some randomness (epsilon-greedy) to avoid local optima
      const directions = ['up', 'down', 'left', 'right'];
      const validMoves = [];
      
      for (const dir of directions) {
        const result = simulateMove(boardState, dir);
        if (result.moved) {
          validMoves.push({
            dir,
            score: fastEvaluate(result.nextState) + result.gain
          });
        }
      }
      
      if (validMoves.length === 0) return null;
      
      // Epsilon-greedy: 20% random, 80% best
      if (Math.random() < 0.2) {
        return validMoves[Math.floor(Math.random() * validMoves.length)].dir;
      }
      
      validMoves.sort((a, b) => b.score - a.score);
      return validMoves[0].dir;
    }

    function fastEvaluate(boardState) {
      // Quick evaluation for simulation speed
      let score = 0;
      const maxTile = Math.max(...boardState.flat());
      const empties = boardState.flat().filter(n => n === 0).length;
      
      // Position weights (snake pattern)
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          score += boardState[r][c] * WEIGHT_MATRIX[r][c];
        }
      }
      
      // Empty bonus
      score += empties * 50000;
      
      // Corner bonus
      if (boardState[0][3] === maxTile) {
        score += maxTile * 10000;
      }
      
      // Monotonicity (simplified)
      let mono = 0;
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size - 1; c++) {
          if (boardState[r][c] >= boardState[r][c + 1]) mono++;
        }
      }
      for (let c = 0; c < size; c++) {
        for (let r = 0; r < size - 1; r++) {
          if (boardState[r][c] >= boardState[r + 1][c]) mono++;
        }
      }
      score += mono * 5000;
      
      return score;
    }

    // Strategy 3: Expectimax Algorithm (Best results)
    function expectimaxMove(boardState, depth = 4) {
      const directions = ['up', 'down', 'left', 'right'];
      let bestMove = null;
      let bestScore = -Infinity;

      for (const dir of directions) {
        const result = simulateMove(boardState, dir);
        if (!result.moved) continue;

        const score = expectimaxValue(result.nextState, depth - 1, false);
        if (score > bestScore) {
          bestScore = score;
          bestMove = dir;
        }
      }

      return bestMove || weightedHeuristicMove(boardState);
    }

    function expectimaxValue(boardState, depth, isPlayerTurn) {
      // Check for terminal state or depth limit
      if (depth === 0) {
        return evaluateBoardExpectimax(boardState);
      }

      if (isPlayerTurn) {
        // Player's turn - maximize
        const directions = ['up', 'down', 'left', 'right'];
        let maxScore = -Infinity;
        let anyMoved = false;

        for (const dir of directions) {
          const result = simulateMove(boardState, dir);
          if (!result.moved) continue;
          anyMoved = true;
          const score = expectimaxValue(result.nextState, depth - 1, false);
          maxScore = Math.max(maxScore, score);
        }

        return anyMoved ? maxScore : evaluateBoardExpectimax(boardState);
      } else {
        // Chance node - expected value of random tile placement
        const empties = [];
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            if (boardState[r][c] === 0) empties.push([r, c]);
          }
        }

        if (empties.length === 0) {
          return expectimaxValue(boardState, depth - 1, true);
        }

        // Sample a subset of empty cells for efficiency
        const sampleSize = Math.min(empties.length, 4);
        const sampled = empties.slice().sort(() => Math.random() - 0.5).slice(0, sampleSize);
        
        let expectedValue = 0;
        for (const [r, c] of sampled) {
          // 90% chance of 2, 10% chance of 4
          const board2 = boardState.map(row => row.slice());
          board2[r][c] = 2;
          expectedValue += 0.9 * expectimaxValue(board2, depth - 1, true);

          const board4 = boardState.map(row => row.slice());
          board4[r][c] = 4;
          expectedValue += 0.1 * expectimaxValue(board4, depth - 1, true);
        }

        return expectedValue / sampled.length;
      }
    }

    function evaluateBoardExpectimax(boardState) {
      let score = 0;

      // 1. Weighted position score (snake pattern)
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          score += boardState[r][c] * WEIGHT_MATRIX[r][c];
        }
      }

      // 2. Empty tiles bonus (critical for survival)
      const empties = boardState.flat().filter(n => n === 0).length;
      score += empties * 50000;

      // 3. Monotonicity bonus (tiles should increase toward corner)
      score += calculateMonotonicity(boardState) * 10000;

      // 4. Smoothness bonus (adjacent tiles should be similar)
      score += calculateSmoothness(boardState) * 1000;

      // 5. Max tile in corner bonus
      const maxTile = Math.max(...boardState.flat());
      if (boardState[0][3] === maxTile) {
        score += maxTile * 10000;
      }

      return score;
    }

    function calculateMonotonicity(boardState) {
      let mono = 0;

      // Check rows (prefer increasing left to right)
      for (let r = 0; r < size; r++) {
        let increasing = 0, decreasing = 0;
        for (let c = 0; c < size - 1; c++) {
          if (boardState[r][c] <= boardState[r][c + 1]) increasing++;
          if (boardState[r][c] >= boardState[r][c + 1]) decreasing++;
        }
        mono += Math.max(increasing, decreasing);
      }

      // Check columns (prefer increasing top to bottom for left cols, decreasing for right)
      for (let c = 0; c < size; c++) {
        let increasing = 0, decreasing = 0;
        for (let r = 0; r < size - 1; r++) {
          if (boardState[r][c] <= boardState[r + 1][c]) increasing++;
          if (boardState[r][c] >= boardState[r + 1][c]) decreasing++;
        }
        mono += Math.max(increasing, decreasing);
      }

      return mono;
    }

    function calculateSmoothness(boardState) {
      let smoothness = 0;

      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (boardState[r][c] === 0) continue;
          const val = Math.log2(boardState[r][c]);

          // Check right neighbor
          if (c < size - 1 && boardState[r][c + 1] !== 0) {
            smoothness -= Math.abs(val - Math.log2(boardState[r][c + 1]));
          }
          // Check bottom neighbor
          if (r < size - 1 && boardState[r + 1][c] !== 0) {
            smoothness -= Math.abs(val - Math.log2(boardState[r + 1][c]));
          }
        }
      }

      return smoothness;
    }

    // Get move based on selected strategy
    let selectedStrategy = 'expectimax';
    const strategyStorageKey = 'aurora-2048-ai-strategy';

    function getStrategyMove(boardState) {
      switch (selectedStrategy) {
        case 'expectimax':
          return expectimaxMove(boardState, 4);
        case 'montecarlo':
          return monteCarloMove(boardState, 100);
        case 'weighted':
          return weightedHeuristicMove(boardState);
        default:
          return weightedHeuristicMove(boardState);
      }
    }

    // Legacy fallback heuristic (used as backup)
    function fallbackHeuristic() {
      return getStrategyMove(board);
    }

    function oldFallbackHeuristic() {
      const order = ['left', 'down', 'right', 'up'];
      let bestMove = null;
      let bestScore = -Infinity;
      for (const dir of order) {
        const result = simulateMove(board, dir);
        if (!result.moved) continue;
        const empties = result.nextState.flat().filter(n => n === 0).length;
        const scoreEstimate = result.gain + empties * 10 + (dir === 'left' || dir === 'down' ? 2 : 0);
        if (scoreEstimate > bestScore) {
          bestScore = scoreEstimate;
          bestMove = dir;
        }
      }
      return bestMove || order.find(dir => simulateMove(board, dir).moved) || 'left';
    }

    async function fetchAzureMove(payload) {
      const model = aiModels[selectedModel];
      const isOpenAI = model.type === 'openai';
      const isAzure = model.type === 'azure';
      
      // Build URL based on provider
      let url;
      if (isAzure) {
        url = `${model.endpoint}/openai/deployments/${model.deployment}/chat/completions?api-version=${model.apiVersion}`;
      } else if (isOpenAI) {
        url = `${model.endpoint}/v1/chat/completions`;
      }
      
      const learnedNote = getLearnedStrategyPrompt();
      
      // Check which moves are valid and what they do
      const moves = ['up', 'right', 'left', 'down'];
      const moveAnalysis = moves.map(dir => {
        const sim = simulateMove(payload.board, dir);
        return `${dir.toUpperCase()}: ${sim.moved ? 'valid' : 'invalid'}${sim.merged ? ', merges' : ''}`;
      }).join('; ');
      
      // Check if max tile is at top-right
      const maxVal = Math.max(...payload.board.flat());
      const anchorStatus = payload.board[0][3] === maxVal ? 
        `Max tile ${maxVal} at top-right (safe)` : 
        `Warning: Max tile ${maxVal} not at top-right`;
      
      // Check if right column is full
      const rightColFull = payload.board.every(row => row[3] !== 0);
      const rightColStatus = rightColFull ? 'Right column full' : 'Right column has space';
      
      // Determine if we should use GPT-5.2 skills and which configuration
      const useSkills = skillsEnabled && (selectedModel.startsWith('gpt-5') || selectedModel === 'openai-gpt-5.2');
      const gpt52Skills = isOpenAI ? gpt52SkillsOpenAI : gpt52SkillsAzure;
      
      let systemPrompt = 'You are an expert 2048 AI strategist.';
      let userPrompt = '';
      
      if (useSkills) {
        // Enhanced prompt to encourage code_interpreter usage
        if (gpt52Skills.codeInterpreter && isOpenAI) {
          systemPrompt += ' You have access to Python code execution via code_interpreter. IMPORTANT: Write and execute Python code to analyze the board state, calculate heuristics, and determine the best move. Also use the available game analysis functions.';
        } else {
          systemPrompt += ' You have access to game analysis functions. Use them to make optimal decisions.';
        }
        
        const codeInstructions = (gpt52Skills.codeInterpreter && isOpenAI) 
          ? [
              'STEP 1: Write Python code to:',
              '  - Parse the board as a 4x4 numpy array',
              '  - Calculate monotonicity score (row/column decreasing patterns)',
              '  - Calculate smoothness (minimize adjacent tile differences)',
              '  - Simulate all 4 moves and evaluate outcomes',
              '  - Score each move considering: merges, empty cells, anchor position',
              '',
              'STEP 2: Execute the code and analyze results',
              'STEP 3: Call game functions if needed for additional validation',
              'STEP 4: Return structured JSON with your code-based recommendation'
            ].join('\n')
          : [
              'Analyze the board using available functions and code execution.',
              'Consider: 1) Anchor safety 2) Monotonicity 3) Merge opportunities 4) Empty space',
              'Return structured JSON with your reasoning and recommended move.'
            ].join('\n');
        
        userPrompt = [
          'BOARD STATE (4x4, 0=empty):',
          payload.prompt,
          '',
          `Move Analysis: ${moveAnalysis}`,
          `Anchor Status: ${anchorStatus}`,
          `Right Column: ${rightColStatus}`,
          '',
          learnedNote || '',
          '',
          codeInstructions
        ].join('\n');
      } else {
        systemPrompt += ' CRITICAL: Never choose DOWN unless the right column is COMPLETELY FULL. Reply with ONLY ONE word: up, left, right, or down.';
        userPrompt = [
          'BOARD STATE (4 rows, 0=empty):',
          payload.prompt,
          '',
          `Move Analysis: ${moveAnalysis}`,
          `Anchor Status: ${anchorStatus}`,
          `Right Column: ${rightColStatus}`,
          '',
          learnedNote || ''
        ].join('\n');
      }

      const body = {
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature: useSkills ? 0.2 : 0.1
      };
      
      // Add model for OpenAI (Azure uses deployment in URL)
      if (isOpenAI) {
        body.model = model.model;
      }

      // Add skills-specific parameters
      if (useSkills) {
        // Build tools array
        const tools = [];
        
        // Add code_interpreter for OpenAI (not supported by Azure)
        if (gpt52Skills.codeInterpreter && isOpenAI) {
          tools.push({ type: 'code_interpreter' });
        }
        
        // Add function calling
        if (gpt52Skills.functionCalling) {
          // OpenAI uses tools array with type 'function'
          if (isOpenAI) {
            for (const func of gameFunctions) {
              tools.push({
                type: 'function',
                function: func
              });
            }
          } else {
            // Azure uses functions parameter directly
            body.functions = gameFunctions;
          }
        }
        
        if (tools.length > 0 && isOpenAI) {
          body.tools = tools;
        }
        
        // Add structured outputs via response_format
        if (gpt52Skills.structuredOutputs) {
          body.response_format = moveDecisionSchema;
        }
        
        // Token limits: Azure uses max_completion_tokens, OpenAI uses max_tokens
        if (isAzure) {
          body.max_completion_tokens = 4000;
        } else {
          body.max_tokens = 4000;
        }
      }

      // Build headers based on provider
      const headers = {
        'Content-Type': 'application/json'
      };
      
      if (isAzure) {
        headers['api-key'] = azureAI.apiKey;
      } else if (isOpenAI) {
        headers['Authorization'] = `Bearer ${openaiApiKey}`;
      }
      
      const res = await fetch(url, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(body)
      });

      if (!res.ok) {
        const text = await res.text();
        const provider = isOpenAI ? 'OpenAI' : 'Azure OpenAI';
        throw new Error(`${provider} API error: ${res.status} ${text}`);
      }

      const data = await res.json();
      
      // Handle skills-enhanced response
      if (useSkills) {
        return await parseGPT52SkillsResponse(data, payload.board);
      }
      
      // Handle basic response
      const choice = data.choices?.[0]?.message?.content?.trim().toLowerCase() || '';
      const allowed = ['up', 'down', 'left', 'right'];
      const move = allowed.find(m => choice.includes(m)) || fallbackHeuristic();
      return move;
    }

    async function parseGPT52SkillsResponse(data, boardState) {
      const message = data.choices?.[0]?.message;
      if (!message) {
        console.error('No message in response:', data);
        return fallbackHeuristic();
      }
      
      // Debug: Log the full message structure
      console.log('GPT-5.2 Response Message:', message);
      
      // Handle function calls - Azure uses function_call, OpenAI uses tool_calls
      if (message.function_call && message.function_call.name) {
        const funcName = message.function_call.name;
        try {
          const args = JSON.parse(message.function_call.arguments || '{}');
          const result = handleFunctionCall(funcName, args);
          console.log(`GPT-5.2 called function ${funcName}:`, result);
        } catch (err) {
          console.error('Error parsing function call arguments:', err);
        }
      } else if (message.function_call && !message.function_call.name) {
        console.log('Skipping empty function_call (structured output mode)');
      }
      
      // Handle OpenAI tool_calls (multiple calls possible)
      let codeInterpreterUsed = false;
      const codeExecutions = [];
      
      if (message.tool_calls && message.tool_calls.length > 0) {
        console.log('Processing tool_calls:', message.tool_calls);
        for (const toolCall of message.tool_calls) {
          if (toolCall.type === 'function') {
            const funcName = toolCall.function?.name;
            if (!funcName) {
              console.error('Tool call with empty function name:', toolCall);
              continue;
            }
            try {
              const args = JSON.parse(toolCall.function.arguments || '{}');
              const result = handleFunctionCall(funcName, args);
              console.log(`âœ“ GPT-5.2 called function ${funcName}:`, result);
            } catch (err) {
              console.error('Error parsing tool call arguments:', err);
            }
          } else if (toolCall.type === 'code_interpreter') {
            // Code interpreter was used!
            codeInterpreterUsed = true;
            const codeInput = toolCall.code_interpreter?.input || 'N/A';
            const codeOutputs = toolCall.code_interpreter?.outputs || [];
            
            console.log('%cğŸ”¬ CODE INTERPRETER USED!', 'color: #00ff00; font-weight: bold; font-size: 14px;');
            console.log('Code Input:', codeInput);
            console.log('Code Outputs:', codeOutputs);
            
            codeExecutions.push({
              input: codeInput,
              outputs: codeOutputs
            });
            
            // Display in skills status
            displayCodeInterpreterUsage(codeInput, codeOutputs);
          }
        }
        // Note: In a full implementation with multi-turn, we would send this back
        // For now, GPT-5.2 uses function results implicitly in its reasoning
      }
      
      // Parse structured JSON response
      try {
        const content = message.content?.trim() || '{}';
        const decision = JSON.parse(content);
        
        if (decision.recommended_move) {
          // Display reasoning if available
          if (decision.reasoning) {
            console.log('AI Reasoning:', decision.reasoning);
          }
          
          // Update skills status with analysis and code interpreter usage
          if (decision.board_analysis) {
            updateSkillsStatus(decision.board_analysis, decision.confidence, codeInterpreterUsed);
          }
          
          return decision.recommended_move;
        }
      } catch (err) {
        console.error('Failed to parse structured response:', err);
      }
      
      // Fallback: try to extract move from unstructured content
      const contentLower = message.content?.toLowerCase() || '';
      const allowed = ['up', 'down', 'left', 'right'];
      return allowed.find(m => contentLower.includes(m)) || fallbackHeuristic();
    }

    function updateSkillsStatus(analysis, confidence, codeInterpreterUsed = false) {
      const statusEl = document.getElementById('skills-status');
      const listEl = document.getElementById('skills-active-list');
      const model = aiModels[selectedModel];
      const isOpenAI = model?.type === 'openai';
      
      const details = [
        `Max: ${analysis.max_tile || 'N/A'}`,
        `Empty: ${analysis.empty_cells || 'N/A'}`,
        `Mono: ${analysis.monotonicity_score?.toFixed(2) || 'N/A'}`,
        `Anchor: ${analysis.anchor_safe ? 'âœ“' : 'âœ—'}`,
        `Conf: ${confidence ? (confidence * 100).toFixed(0) + '%' : 'N/A'}`
      ].join(' | ');
      
      const codeStatus = codeInterpreterUsed ? 'ğŸ”¬ Code: âœ“ USED' : (isOpenAI ? 'Code: â—‹' : 'Code: âœ—');
      const skillsInfo = isOpenAI 
        ? `Functions: âœ“ | Structured: âœ“ | ${codeStatus}` 
        : 'Functions: âœ“ | Structured: âœ“ | Code: âœ— (Azure)';
      
      listEl.innerHTML = `<small>${details}</small><br><small style="opacity: 0.7;">${skillsInfo}</small>`;
      statusEl.style.display = 'block';
    }
    
    function displayCodeInterpreterUsage(codeInput, codeOutputs) {
      const statusEl = document.getElementById('skills-status');
      const listEl = document.getElementById('skills-active-list');
      
      // Create detailed display
      let outputsHtml = '';
      if (codeOutputs && codeOutputs.length > 0) {
        outputsHtml = codeOutputs.map((output, idx) => {
          if (output.type === 'logs') {
            return `<div style="margin-top: 8px;"><strong>Log ${idx + 1}:</strong><pre style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; font-size: 11px; overflow-x: auto;">${output.logs || 'N/A'}</pre></div>`;
          } else if (output.type === 'image') {
            return `<div style="margin-top: 8px;"><strong>Image ${idx + 1}:</strong> <em>Generated</em></div>`;
          } else {
            return `<div style="margin-top: 8px;"><strong>Output ${idx + 1}:</strong> ${JSON.stringify(output)}</div>`;
          }
        }).join('');
      } else {
        outputsHtml = '<div style="margin-top: 8px; color: var(--muted);">No outputs captured</div>';
      }
      
      const codeHtml = `
        <div style="margin-top: 10px; padding: 10px; background: rgba(0, 255, 0, 0.05); border: 1px solid rgba(0, 255, 0, 0.2); border-radius: 8px;">
          <strong style="color: #00ff00;">ğŸ”¬ CODE INTERPRETER EXECUTED!</strong>
          <div style="margin-top: 8px;"><strong>Code Input:</strong></div>
          <pre style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; font-size: 11px; overflow-x: auto; margin-top: 4px;">${codeInput}</pre>
          ${outputsHtml}
        </div>
      `;
      
      // Prepend to existing content
      listEl.innerHTML = codeHtml + listEl.innerHTML;
      statusEl.style.display = 'block';
    }

    async function aiPlay() {
      if (aiPlaying) {
        aiPlaying = false;
        aiPlayBtn.textContent = 'AI Play';
        askAiBtn.disabled = false;
        setAiStatus('AI autoplay stopped.');
        return;
      }

      aiPlaying = true;
      aiPlayBtn.textContent = 'Stop AI';
      askAiBtn.disabled = true;
      const strategyNames = {
        'expectimax': 'Expectimax',
        'montecarlo': 'Monte Carlo',
        'weighted': 'Weighted Heuristic',
        'llm': selectedModel
      };
      setAiStatus(`<strong>AI autoplay</strong> running with ${strategyNames[selectedStrategy]} until no moves left.`);

      while (aiPlaying) {
        if (isGameOver()) {
          setAiStatus('No moves left. AI autoplay stopped.');
          break;
        }

        const payload = {
          board: board.map(row => row.slice()),
          score,
          best,
          theme,
          prompt: formatBoardForAI()
        };

        let direction = null;
        try {
          const { move, source } = await requestAIMove(payload);
          // Only apply anchorGuard for LLM strategy (local algorithms already handle this)
          const guarded = selectedStrategy === 'llm' ? anchorGuard(move) : move;
          direction = guarded;
          if (guarded !== move) {
            setAiStatus(`<strong>AI move (guarded):</strong> ${guarded.toUpperCase()} instead of ${move.toUpperCase()} to protect the top-right anchor (${source}).`);
          } else {
            setAiStatus(`<strong>AI move:</strong> ${move.toUpperCase()} (${source}).`);
          }
        } catch (err) {
          console.error(err);
          direction = getStrategyMove(board);
          setAiStatus(`AI request failed; using fallback move ${direction.toUpperCase()}.`);
        }

        if (!direction) {
          setAiStatus('AI did not return a move. Stopping.');
          break;
        }

        const before = JSON.stringify(board);
        move(direction);
        if (JSON.stringify(board) === before) {
          // If move had no effect, try a fallback alternate once.
          const alt = getStrategyMove(board);
          if (alt && alt !== direction) {
            move(alt);
            setAiStatus(`Move ${direction.toUpperCase()} blocked; tried ${alt.toUpperCase()} instead.`);
          } else {
            setAiStatus(`Move ${direction.toUpperCase()} had no effect. Stopping.`);
            break;
          }
        }

        if (!aiPlaying) break;
        if (isGameOver()) {
          setAiStatus('No moves left. AI autoplay stopped.');
          break;
        }

        await delay(180);
      }

      aiPlaying = false;
      aiPlayBtn.textContent = 'AI Play';
      askAiBtn.disabled = false;
    }

    async function requestAIMove(payload) {
      // If using local algorithm strategies
      if (selectedStrategy !== 'llm') {
        const move = getStrategyMove(payload.board);
        const strategyNames = {
          'expectimax': 'Expectimax',
          'montecarlo': 'Monte Carlo',
          'weighted': 'Weighted Heuristic'
        };
        return { move, source: strategyNames[selectedStrategy] || selectedStrategy };
      }
      
      // LLM strategy - use Azure OpenAI
      const configured = Boolean(
        azureAI.apiKey &&
        aiModels[selectedModel] &&
        !aiModels[selectedModel].endpoint.includes('YOUR-')
      );
      if (configured) {
        const move = await fetchAzureMove(payload);
        return { move, source: selectedModel };
      }
      // Fallback if LLM not configured
      const move = getStrategyMove(payload.board);
      return { move, source: 'local algorithm (LLM not configured)' };
    }

    async function callAIForMove() {
      if (aiThinking) return;
      aiThinking = true;
      askAiBtn.disabled = true;
      
      const strategyNames = {
        'expectimax': 'Expectimax algorithm',
        'montecarlo': 'Monte Carlo simulation',
        'weighted': 'Weighted heuristic',
        'llm': `${selectedModel}`
      };
      setAiStatus(`<strong>AI thinkingâ€¦</strong> using ${strategyNames[selectedStrategy]}`);

      const payload = {
        board: board.map(row => row.slice()),
        score,
        best,
        theme,
        prompt: formatBoardForAI()
      };

      try {
        const { move, source } = await requestAIMove(payload);
        // Only apply anchorGuard for LLM strategy
        const guarded = selectedStrategy === 'llm' ? anchorGuard(move) : move;
        if (guarded !== move) {
          setAiStatus(`<strong>AI suggests (guarded):</strong> ${guarded.toUpperCase()} instead of ${move.toUpperCase()} to protect the top-right anchor (${source}).`);
        } else {
          setAiStatus(`<strong>AI suggests:</strong> ${move.toUpperCase()} (${source}).`);
        }
      } catch (err) {
        console.error(err);
        const move = getStrategyMove(board);
        setAiStatus(`AI request failed, using fallback: ${move.toUpperCase()}.`);
      } finally {
        aiThinking = false;
        askAiBtn.disabled = false;
      }
    }

    function showMessage(title, text) {
      acceptInput = false;
      messageTitle.textContent = title;
      messageText.textContent = text;
      messageEl.classList.add('show');
    }

    function hideMessage() {
      acceptInput = true;
      messageEl.classList.remove('show');
    }

    // Records board state and the move direction that will be applied from this state
    function recordMoveToHistory(direction, boardBeforeMove) {
      moveHistory.push({
        move: direction,  // The move to be applied from this board state
        board: boardBeforeMove.map(row => row.slice())  // Board state before the move
      });
    }

    function renderMoveHistory() {
      historyListEl.innerHTML = '';
      moveHistory.forEach((entry, index) => {
        const item = document.createElement('div');
        item.className = 'history-item';
        
        const moveLabel = document.createElement('div');
        moveLabel.className = 'history-move';
        const directions = { 'up': 'â†‘', 'down': 'â†“', 'left': 'â†', 'right': 'â†’' };
        
        const moveText = document.createElement('span');
        // Show step number, then "â†’" to indicate the move that will be applied
        moveText.textContent = `Step ${index + 1} ${directions[entry.move] || entry.move.toUpperCase()}`;
        moveLabel.appendChild(moveText);
        
        const btnContainer = document.createElement('div');
        btnContainer.style.display = 'flex';
        btnContainer.style.gap = '4px';
        
        const revertBtn = document.createElement('button');
        revertBtn.className = 'copy-move-btn';
        revertBtn.textContent = 'â†¶';
        revertBtn.title = 'Revert to this board state';
        revertBtn.onclick = (e) => {
          e.stopPropagation();
          revertToBoardState(index);
        };
        btnContainer.appendChild(revertBtn);
        
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-move-btn';
        copyBtn.textContent = 'ğŸ“‹';
        copyBtn.title = 'Copy this board state';
        copyBtn.onclick = (e) => {
          e.stopPropagation();
          copyBoardState(entry.board, index + 1, entry.move);
        };
        btnContainer.appendChild(copyBtn);
        
        moveLabel.appendChild(btnContainer);
        
        item.appendChild(moveLabel);

        const gridDiv = document.createElement('div');
        gridDiv.className = 'history-grid';
        
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const value = entry.board[r][c];
            const cell = document.createElement('div');
            cell.className = 'history-cell';
            if (value > 0) {
              cell.classList.add('filled');
              // Show full number up to 512, then abbreviate (1024=1k, 2048=2k, etc.)
              cell.textContent = value <= 512 ? value : (value / 1024) + 'k';
            }
            gridDiv.appendChild(cell);
          }
        }
        item.appendChild(gridDiv);
        historyListEl.appendChild(item);
      });
      
      // Scroll to bottom to show latest move
      historyListEl.parentElement.scrollTop = historyListEl.parentElement.scrollHeight;
    }

    function saveGameState() {
      const gameState = {
        board: board.map(row => row.slice()),
        score,
        history,
        moveHistory,
        acceptInput
      };
      localStorage.setItem('aurora-2048-game-state', JSON.stringify(gameState));
    }

    function loadGameState() {
      const saved = localStorage.getItem('aurora-2048-game-state');
      if (!saved) return false;
      
      try {
        const gameState = JSON.parse(saved);
        board = gameState.board || Array.from({ length: size }, () => Array(size).fill(0));
        score = gameState.score || 0;
        history = gameState.history || [];
        moveHistory = gameState.moveHistory || [];
        acceptInput = gameState.acceptInput !== false;
        
        hideMessage();
        updateUI();
        renderMoveHistory();
        return true;
      } catch (err) {
        console.error('Failed to load game state:', err);
        return false;
      }
    }

    function setupInput() {
      document.addEventListener('keydown', (event) => {
        const key = event.key.toLowerCase();
        if (key === 'arrowleft' || key === 'a') { event.preventDefault(); move('left'); }
        if (key === 'arrowright' || key === 'd') { event.preventDefault(); move('right'); }
        if (key === 'arrowup' || key === 'w') { event.preventDefault(); move('up'); }
        if (key === 'arrowdown' || key === 's') { event.preventDefault(); move('down'); }
        if (key === 'u' || (event.metaKey && key === 'z') || (event.ctrlKey && key === 'z')) { event.preventDefault(); undo(); }
      });

      let touchStart = null;
      gridEl.addEventListener('touchstart', (e) => {
        const touch = e.changedTouches[0];
        touchStart = { x: touch.clientX, y: touch.clientY };
      }, { passive: true });

      gridEl.addEventListener('touchend', (e) => {
        if (!touchStart) return;
        const touch = e.changedTouches[0];
        const dx = touch.clientX - touchStart.x;
        const dy = touch.clientY - touchStart.y;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        if (Math.max(absX, absY) < 24) return;
        if (absX > absY) {
          move(dx > 0 ? 'right' : 'left');
        } else {
          move(dy > 0 ? 'down' : 'up');
        }
        touchStart = null;
      }, { passive: true });

      continueBtn.addEventListener('click', () => {
        hideMessage();
        acceptInput = true;
      });

      newGameBtn.addEventListener('click', () => {
        if (!muted) ensureAudio();
        newGame();
      });

      undoBtn.addEventListener('click', () => {
        undo();
      });

      themeToggleBtn.addEventListener('click', () => {
        toggleTheme();
      });

      muteToggleBtn.addEventListener('click', () => {
        toggleMute();
      });

      askAiBtn.addEventListener('click', () => {
        callAIForMove();
      });

      aiPlayBtn.addEventListener('click', () => {
        aiPlay();
      });

      learnStrategyBtn.addEventListener('click', () => {
        analyzeAndLearnStrategy();
      });

      clearStrategyBtn.addEventListener('click', () => {
        clearLearnedStrategy();
      });

      const learnFromCollectionBtn = document.getElementById('learn-from-collection');
      learnFromCollectionBtn.addEventListener('click', () => {
        analyzeMultipleGames();
      });

      const importBtn = document.getElementById('import-btn');
      const importInput = document.getElementById('import-histories');
      importBtn.addEventListener('click', () => importInput.click());
      importInput.addEventListener('change', (e) => importHistoryFiles(e.target.files));

      const clearCollectionBtn = document.getElementById('clear-collection');
      clearCollectionBtn.addEventListener('click', clearGameCollection);

      aiModelSelect.addEventListener('change', () => {
        selectedModel = aiModelSelect.value;
        localStorage.setItem(modelStorageKey, selectedModel);
        
        // Load appropriate API key for the new model
        const model = aiModels[selectedModel];
        if (model.type === 'openai') {
          const saved = localStorage.getItem(openaiApiKeyStorageKey);
          if (saved) {
            openaiApiKey = saved;
            setAiStatus('Using OpenAI GPT-5.2 with full skills support (including code interpreter).');
          } else {
            promptForApiKey();
          }
        } else if (model.type === 'azure') {
          const saved = localStorage.getItem(apiKeyStorageKey);
          if (saved) {
            azureAI.apiKey = saved;
            setAiStatus('Using Azure OpenAI (function calling & structured outputs only).');
          } else {
            promptForApiKey();
          }
        }
        
        updateSkillsToggleVisibility();
        if (selectedStrategy === 'llm') {
          updateAiStatusForStrategy();
        }
      });

      const enableSkillsCheckbox = document.getElementById('enable-skills');
      enableSkillsCheckbox.addEventListener('change', () => {
        skillsEnabled = enableSkillsCheckbox.checked;
        localStorage.setItem(skillsStorageKey, skillsEnabled ? '1' : '0');
        updateSkillsStatusVisibility();
        setAiStatus(`GPT-5.2 Skills ${skillsEnabled ? 'enabled' : 'disabled'}.`);
      });

      copyHistoryBtn.addEventListener('click', () => {
        copyMoveHistory();
      });

      const downloadHistoryBtn = document.getElementById('download-history');
      downloadHistoryBtn.addEventListener('click', () => {
        downloadMoveHistoryJSON();
      });

      const loadHistoryBtn = document.getElementById('load-history');
      const loadHistoryInput = document.getElementById('load-history-input');
      loadHistoryBtn.addEventListener('click', () => loadHistoryInput.click());
      loadHistoryInput.addEventListener('change', (e) => {
        if (e.target.files && e.target.files[0]) {
          loadMoveHistoryFromJSON(e.target.files[0]);
          e.target.value = ''; // Reset input
        }
      });
    }

    function downloadMoveHistoryJSON() {
      if (moveHistory.length === 0) {
        alert('No moves to download yet!');
        return;
      }

      // Create JSON data
      const historyData = {
        game: '2048 Aurora Edition',
        totalMoves: moveHistory.length,
        finalScore: score,
        bestScore: best,
        timestamp: new Date().toISOString(),
        moves: moveHistory.map((entry, index) => ({
          moveNumber: index + 1,
          direction: entry.move,
          boardState: entry.board
        }))
      };

      // Convert to JSON string
      const jsonString = JSON.stringify(historyData, null, 2);
      
      // Create blob and download
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `2048-history-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      // Visual feedback
      const downloadHistoryBtn = document.getElementById('download-history');
      const originalText = downloadHistoryBtn.textContent;
      downloadHistoryBtn.textContent = 'âœ“ Downloaded!';
      downloadHistoryBtn.style.background = 'rgba(135, 246, 255, 0.2)';
      downloadHistoryBtn.style.borderColor = 'rgba(135, 246, 255, 0.4)';
      
      setTimeout(() => {
        downloadHistoryBtn.textContent = originalText;
        downloadHistoryBtn.style.background = '';
        downloadHistoryBtn.style.borderColor = '';
      }, 2000);
    }

    async function loadMoveHistoryFromJSON(file) {
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        
        // Validate the data structure
        if (!data.moves || !Array.isArray(data.moves) || data.moves.length === 0) {
          alert('Invalid JSON file: no moves found.');
          return;
        }
        
        // Confirm loading
        if (moveHistory.length > 0) {
          if (!confirm(`This will replace your current game (${moveHistory.length} moves). Continue?`)) {
            return;
          }
        }
        
        // Load the move history
        moveHistory = data.moves.map(m => ({
          move: m.direction || m.move,
          board: m.boardState || m.board
        }));
        
        // Restore the last board state
        const lastMove = moveHistory[moveHistory.length - 1];
        board = lastMove.board.map(row => row.slice());
        
        // Recalculate score from board
        score = data.finalScore || 0;
        
        // Reset history stack
        history = [];
        
        // Update UI
        acceptInput = true;
        hideMessage();
        updateUI();
        renderMoveHistory();
        saveGameState();
        
        setAiStatus(`Loaded ${moveHistory.length} moves from ${file.name}. Score: ${score}`);
        
        // Visual feedback on button
        const loadHistoryBtn = document.getElementById('load-history');
        loadHistoryBtn.style.background = 'rgba(135, 246, 255, 0.2)';
        loadHistoryBtn.style.borderColor = 'rgba(135, 246, 255, 0.4)';
        setTimeout(() => {
          loadHistoryBtn.style.background = '';
          loadHistoryBtn.style.borderColor = '';
        }, 2000);
        
      } catch (err) {
        console.error('Failed to load JSON:', err);
        alert('Failed to load JSON file: ' + err.message);
      }
    }

    function copyMoveHistory() {
      if (moveHistory.length === 0) {
        alert('No moves to copy yet!');
        return;
      }

      // Format moves into a text block
      let text = `2048 Game Move History (${moveHistory.length} moves, Score: ${score})\n\n`;
      
      moveHistory.forEach((entry, index) => {
        const moveNum = index + 1;
        const direction = entry.move.toUpperCase();
        const boardStr = entry.board.map(row => 
          row.map(v => (v === 0 ? '.' : String(v).padStart(4, ' '))).join(' ')
        ).join('\n');
        
        text += `Move ${moveNum}: ${direction}\n${boardStr}\n\n`;
      });

      // Copy to clipboard
      navigator.clipboard.writeText(text).then(() => {
        // Visual feedback
        const originalText = copyHistoryBtn.textContent;
        copyHistoryBtn.textContent = 'âœ“ Copied!';
        copyHistoryBtn.style.background = 'rgba(135, 246, 255, 0.2)';
        copyHistoryBtn.style.borderColor = 'rgba(135, 246, 255, 0.4)';
        
        setTimeout(() => {
          copyHistoryBtn.textContent = originalText;
          copyHistoryBtn.style.background = '';
          copyHistoryBtn.style.borderColor = '';
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy to clipboard. Please try again.');
      });
    }

    function copyBoardState(boardState, moveNum, direction) {
      // Format single board state as text
      const directionText = {
        'up': 'â†‘ Up',
        'down': 'â†“ Down',
        'left': 'â† Left',
        'right': 'â†’ Right'
      }[direction] || direction;
      
      let text = `Move ${moveNum}: ${directionText}\n\n`;
      
      boardState.forEach(row => {
        text += row.map(cell => {
          const value = cell || 0;
          return String(value).padStart(4, ' ');
        }).join(' ') + '\n';
      });

      // Copy to clipboard
      navigator.clipboard.writeText(text).then(() => {
        // Find the button that was clicked and give visual feedback
        const buttons = document.querySelectorAll('.copy-move-btn');
        buttons.forEach(btn => {
          if (btn.getAttribute('data-move-num') == moveNum) {
            const originalText = btn.textContent;
            btn.textContent = 'âœ“';
            btn.style.background = 'rgba(135, 246, 255, 0.2)';
            btn.style.borderColor = 'rgba(135, 246, 255, 0.4)';
            
            setTimeout(() => {
              btn.textContent = originalText;
              btn.style.background = '';
              btn.style.borderColor = '';
            }, 1000);
          }
        });
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy to clipboard.');
      });
    }

    function revertToBoardState(moveIndex) {
      if (moveIndex < 0 || moveIndex >= moveHistory.length) return;
      
      // Confirm the revert action
      const movesRemoved = moveHistory.length - moveIndex - 1;
      if (movesRemoved > 0) {
        const confirmMsg = `This will revert to Move ${moveIndex + 1} and remove ${movesRemoved} move${movesRemoved > 1 ? 's' : ''} after it. Continue?`;
        if (!confirm(confirmMsg)) return;
      }
      
      // Restore the board state
      const targetState = moveHistory[moveIndex];
      board = targetState.board.map(row => row.slice());
      
      // Recalculate score based on board state
      score = 0;
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (board[r][c] > 0) {
            score += board[r][c];
          }
        }
      }
      
      // Truncate move history and undo history
      moveHistory = moveHistory.slice(0, moveIndex + 1);
      history = [board.map(row => row.slice())];
      
      // Update UI
      updateUI();
      renderMoveHistory();
      saveGameState();
      
      // Visual feedback on button
      const buttons = document.querySelectorAll('.revert-move-btn');
      buttons.forEach(btn => {
        if (btn.closest('.history-item') === document.querySelectorAll('.history-item')[moveIndex]) {
          const originalText = btn.textContent;
          btn.textContent = 'âœ“';
          btn.style.background = 'rgba(135, 246, 255, 0.2)';
          btn.style.borderColor = 'rgba(135, 246, 255, 0.4)';
          
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
            btn.style.borderColor = '';
          }, 1000);
        }
      });
      
      // Show feedback
      setAiStatus(`Reverted to Move ${moveIndex + 1}`);
    }

    function loadSelectedStrategy() {
      const saved = localStorage.getItem(strategyStorageKey);
      if (saved && ['expectimax', 'montecarlo', 'weighted', 'llm'].includes(saved)) {
        selectedStrategy = saved;
        aiStrategySelect.value = saved;
      }
      // Show/hide model dropdown based on strategy
      aiModelSelect.style.display = selectedStrategy === 'llm' ? '' : 'none';
      updateAiStatusForStrategy();
    }

    function updateAiStatusForStrategy() {
      const strategyDescriptions = {
        'expectimax': 'Expectimax (depth 4) - Best results, ~80% win rate',
        'montecarlo': 'Monte Carlo (100 sims) - Good results, random sampling',
        'weighted': 'Weighted Heuristic - Fast, snake pattern',
        'llm': `LLM (${selectedModel}) - Cloud AI, slower`
      };
      setAiStatus(`AI Strategy: <strong>${strategyDescriptions[selectedStrategy]}</strong>. Click "Ask AI" or "AI Play".`);
    }

    // Strategy dropdown change handler
    aiStrategySelect.addEventListener('change', () => {
      selectedStrategy = aiStrategySelect.value;
      localStorage.setItem(strategyStorageKey, selectedStrategy);
      // Show/hide model dropdown based on strategy
      aiModelSelect.style.display = selectedStrategy === 'llm' ? '' : 'none';
      updateSkillsToggleVisibility();
      updateSkillsStatusVisibility();
      updateAiStatusForStrategy();
    });

    function loadSelectedModel() {
      const saved = localStorage.getItem(modelStorageKey);
      if (saved && aiModels[saved]) {
        selectedModel = saved;
        aiModelSelect.value = saved;
      }
      
      // Load skills setting
      const savedSkills = localStorage.getItem(skillsStorageKey);
      if (savedSkills !== null) {
        skillsEnabled = savedSkills === '1';
        document.getElementById('enable-skills').checked = skillsEnabled;
      }
      
      updateSkillsToggleVisibility();
      updateSkillsStatusVisibility();
      
      // Only update status if LLM is selected
      if (selectedStrategy === 'llm') {
        updateAiStatusForStrategy();
      }
    }

    function updateSkillsToggleVisibility() {
      const container = document.getElementById('skills-toggle-container');
      // Show skills toggle for GPT-5.x models (both Azure and OpenAI) when LLM strategy is selected
      const showToggle = selectedStrategy === 'llm' && (selectedModel.startsWith('gpt-5') || selectedModel === 'openai-gpt-5.2');
      container.style.display = showToggle ? 'flex' : 'none';
    }

    function updateSkillsStatusVisibility() {
      const statusEl = document.getElementById('skills-status');
      if (!skillsEnabled || selectedStrategy !== 'llm' || (!selectedModel.startsWith('gpt-5') && selectedModel !== 'openai-gpt-5.2')) {
        statusEl.style.display = 'none';
      }
    }

    async function analyzeAndLearnStrategy() {
      if (moveHistory.length < 2) {
        strategyResultEl.style.display = 'none';
        alert('Need at least 2 moves to analyze strategy. Play more!');
        return;
      }

      // Check if Azure AI is configured
      const configured = Boolean(
        azureAI.apiKey &&
        aiModels[selectedModel] &&
        !aiModels[selectedModel].endpoint.includes('YOUR-')
      );

      if (!configured) {
        alert('Please configure Azure OpenAI API key first. AI is needed to analyze your strategy.');
        return;
      }

      // Show loading state
      learnStrategyBtn.disabled = true;
      learnStrategyBtn.textContent = 'ğŸ”„ AI Analyzing...';
      strategyResultEl.innerHTML = `<strong>ğŸ¤– ${selectedModel} is analyzing your gameplay...</strong>`;
      strategyResultEl.style.display = 'block';

      // Prepare detailed move history with board states for AI analysis
      const totalMoves = moveHistory.length;
      
      // Build detailed game log showing board state transitions
      const gameLog = moveHistory.map((entry, index) => {
        const boardStr = entry.board.map(row => row.map(v => v === 0 ? '.' : v).join('\t')).join('\n');
        return `Move ${index + 1}: ${entry.move.toUpperCase()}\nBoard after:\n${boardStr}`;
      }).join('\n\n');

      const prompt = `You are an expert 2048 strategy coach. Analyze this player's gameplay and learn their decision-making patterns to teach an AI how to play in their style.

GAME LOG (${totalMoves} moves, final score: ${score}):
${gameLog}

Based on this gameplay, create a STRATEGIC GUIDE that describes HOW TO MAKE DECISIONS in different game situations. Focus on:
1. When to use each direction based on board state
2. How to handle the largest tile positioning
3. Merge priority decisions
4. Emergency/recovery situations

Respond in EXACTLY this JSON format (no other text):
{
  "style": "A short name for their play style",
  "rules": [
    "Rule 1: When [situation], move [direction] because [reason]",
    "Rule 2: When [situation], move [direction] because [reason]",
    "Rule 3: ...",
    "Rule 4: ...",
    "Rule 5: ..."
  ],
  "cornerStrategy": "Which corner they anchor to and how they maintain it",
  "mergeStrategy": "How they prioritize merges (chain merges vs immediate merges)",
  "emergencyMoves": "What they do when the board is filling up or in danger",
  "avoidPatterns": "Moves or situations they avoid and why",
  "summary": "A 2-3 sentence summary of how to play like this player"
}`;

      try {
        const model = aiModels[selectedModel];
        const url = `${model.endpoint}/openai/deployments/${model.deployment}/chat/completions?api-version=${model.apiVersion}`;
        const body = {
          messages: [
            { role: 'system', content: 'You are an expert 2048 strategy analyst. Respond only with valid JSON.' },
            { role: 'user', content: prompt }
          ],
          temperature: 0.3,
        };

        const res = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'api-key': azureAI.apiKey
          },
          body: JSON.stringify(body)
        });

        if (!res.ok) {
          throw new Error(`${selectedModel} error: ${res.status}`);
        }

        const data = await res.json();
        const content = data.choices?.[0]?.message?.content?.trim() || '';
        
        // Parse AI response
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error('Invalid AI response format');
        }

        const aiAnalysis = JSON.parse(jsonMatch[0]);

        // Store learned strategy with AI analysis
        learnedStrategy = {
          style: aiAnalysis.style || 'Unknown',
          rules: aiAnalysis.rules || [],
          cornerStrategy: aiAnalysis.cornerStrategy || '',
          mergeStrategy: aiAnalysis.mergeStrategy || '',
          emergencyMoves: aiAnalysis.emergencyMoves || '',
          avoidPatterns: aiAnalysis.avoidPatterns || '',
          summary: aiAnalysis.summary || '',
          totalMoves,
          finalScore: score,
          analyzedByAI: true
        };

        // Save to localStorage
        localStorage.setItem('aurora-2048-learned-strategy', JSON.stringify(learnedStrategy));

        // Display results
        displayStrategyAnalysis();

      } catch (err) {
        console.error('AI analysis error:', err);
        strategyResultEl.innerHTML = `<strong>âŒ AI Analysis Failed:</strong> ${err.message}. Please try again.`;
      } finally {
        learnStrategyBtn.disabled = false;
        learnStrategyBtn.textContent = 'ğŸ“š Learn Strategy';
      }
    }

    function displayStrategyAnalysis() {
      if (!learnedStrategy) return;

      const { style, rules, cornerStrategy, mergeStrategy, summary, totalMoves, finalScore, analyzedByAI } = learnedStrategy;

      const aiTag = analyzedByAI ? 'ğŸ¤– AI-Analyzed' : 'ğŸ“Š Basic';
      const rulesHtml = rules && rules.length > 0 
        ? `<strong>Decision Rules:</strong><br>${rules.map(r => `â€¢ ${r}`).join('<br>')}<br>` 
        : '';
      
      const html = `
        <strong>${aiTag} Strategy Profile (${totalMoves} moves, Score: ${finalScore})</strong><br>
        <small style="color: var(--accent);">
          <strong>Style:</strong> ${style}<br>
          ${cornerStrategy ? `<strong>Corner Strategy:</strong> ${cornerStrategy}<br>` : ''}
          ${mergeStrategy ? `<strong>Merge Strategy:</strong> ${mergeStrategy}<br>` : ''}
          ${rulesHtml}
          ${summary ? `<strong>Summary:</strong> ${summary}<br>` : ''}
          <em>âœ“ AI will now play using your learned strategy!</em>
        </small>
      `;

      strategyResultEl.innerHTML = html;
      strategyResultEl.style.display = 'block';
      
      // Update learned note textbox
      updateLearnedNoteDisplay();
    }

    function updateLearnedNoteDisplay() {
      const note = getLearnedStrategyPrompt();
      if (note) {
        learnedNoteEl.value = note;
        learnedNoteContainer.style.display = 'block';
      } else {
        learnedNoteEl.value = '';
        learnedNoteContainer.style.display = 'none';
      }
    }

    function clearLearnedStrategy() {
      learnedStrategy = null;
      localStorage.removeItem('aurora-2048-learned-strategy');
      strategyResultEl.style.display = 'none';
      strategyResultEl.innerHTML = '';
      learnedNoteContainer.style.display = 'none';
      learnedNoteEl.value = '';
      setAiStatus('Learned strategy cleared. AI will use default strategy.');
    }

    function getLearnedStrategyPrompt() {
      if (!learnedStrategy) return '';

      const { style, rules, cornerStrategy, mergeStrategy, emergencyMoves, avoidPatterns, winningPatterns, summary, multiGame, gamesAnalyzed } = learnedStrategy;
      
      let prompt = multiGame 
        ? `\nLEARNED STRATEGY FROM ${gamesAnalyzed} GAMES:\nStyle: ${style}`
        : `\nLEARNED STRATEGY FROM PLAYER'S GAMEPLAY:\nStyle: ${style}`;

      prompt += `\n\nDECISION RULES - Follow these when choosing moves:`;

      if (rules && rules.length > 0) {
        rules.forEach((rule, i) => {
          prompt += `\n${i + 1}. ${rule}`;
        });
      }

      if (cornerStrategy) {
        prompt += `\n\nCORNER STRATEGY:\n${cornerStrategy}`;
      }
      
      if (mergeStrategy) {
        prompt += `\n\nMERGE STRATEGY:\n${mergeStrategy}`;
      }

      if (winningPatterns) {
        prompt += `\n\nWINNING PATTERNS (from high-scoring games):\n${winningPatterns}`;
      }

      if (emergencyMoves) {
        prompt += `\n\nEMERGENCY MOVES (when board is filling up):\n${emergencyMoves}`;
      }

      if (avoidPatterns) {
        prompt += `\n\nAVOID THESE PATTERNS:\n${avoidPatterns}`;
      }

      if (summary) {
        prompt += `\n\nOVERALL APPROACH:\n${summary}`;
      }

      prompt += `\n\nIMPORTANT: Apply these learned rules to decide the best move for the current board state.`;
      
      return prompt;
    }

    function loadLearnedStrategy() {
      const saved = localStorage.getItem('aurora-2048-learned-strategy');
      if (saved) {
        learnedStrategy = JSON.parse(saved);
        // Display saved strategy on load
        displayStrategyAnalysis();
      }
    }

    // ========== GAME COLLECTION FUNCTIONS ==========
    
    function loadGameCollection() {
      const saved = localStorage.getItem(gameCollectionStorageKey);
      if (saved) {
        gameCollection = JSON.parse(saved);
      }
      renderCollectionStats();
    }

    function saveGameCollection() {
      localStorage.setItem(gameCollectionStorageKey, JSON.stringify(gameCollection));
      renderCollectionStats();
    }

    function saveGameToCollection() {
      if (moveHistory.length < 5) return; // Don't save very short games
      
      const maxTile = Math.max(...board.flat());
      const gameData = {
        id: Date.now(),
        timestamp: new Date().toISOString(),
        moves: moveHistory.map(m => ({ move: m.move, board: m.board })),
        totalMoves: moveHistory.length,
        finalScore: score,
        maxTile: maxTile,
        won: maxTile >= 2048
      };
      
      gameCollection.push(gameData);
      
      // Keep last 50 games max
      if (gameCollection.length > 50) {
        gameCollection = gameCollection.slice(-50);
      }
      
      saveGameCollection();
      setAiStatus(`Game saved to collection! (${gameCollection.length} games total)`);
    }

    function clearGameCollection() {
      if (!confirm(`Delete all ${gameCollection.length} saved games?`)) return;
      gameCollection = [];
      saveGameCollection();
      setAiStatus('Game collection cleared.');
    }

    function removeGameFromCollection(gameId) {
      gameCollection = gameCollection.filter(g => g.id !== gameId);
      saveGameCollection();
    }

    function renderCollectionStats() {
      const statsEl = document.getElementById('collection-stats');
      const listEl = document.getElementById('collection-list');
      
      if (gameCollection.length === 0) {
        statsEl.innerHTML = 'No games saved yet. Complete games to build your collection, or import JSON files.';
        listEl.innerHTML = '';
        return;
      }
      
      const totalGames = gameCollection.length;
      const avgScore = Math.round(gameCollection.reduce((sum, g) => sum + g.finalScore, 0) / totalGames);
      const bestScore = Math.max(...gameCollection.map(g => g.finalScore));
      const wins = gameCollection.filter(g => g.won).length;
      const maxTileEver = Math.max(...gameCollection.map(g => g.maxTile));
      
      statsEl.innerHTML = `
        <strong>${totalGames}</strong> games saved | 
        Avg: <strong>${avgScore}</strong> | 
        Best: <strong>${bestScore}</strong> | 
        Wins: <strong>${wins}</strong> | 
        Max Tile: <strong>${maxTileEver}</strong>
      `;
      
      // Render game list (last 10)
      const recentGames = gameCollection.slice(-10).reverse();
      listEl.innerHTML = recentGames.map(g => `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: rgba(255,255,255,0.03); border-radius: 6px; margin-bottom: 4px; font-size: 12px;">
          <span>${new Date(g.timestamp).toLocaleDateString()} - Score: ${g.finalScore} (${g.totalMoves} moves, max ${g.maxTile}${g.won ? ' ğŸ†' : ''})</span>
          <button onclick="removeGameFromCollection(${g.id})" style="background: none; border: none; color: var(--muted); cursor: pointer; padding: 2px 6px;">&times;</button>
        </div>
      `).join('');
    }

    async function importHistoryFiles(files) {
      if (!files || files.length === 0) return;
      
      let imported = 0;
      let errors = 0;
      
      for (const file of files) {
        try {
          const text = await file.text();
          const data = JSON.parse(text);
          
          // Handle both single game and array format
          const games = Array.isArray(data) ? data : [data];
          
          for (const game of games) {
            // Validate and normalize the data
            if (game.moves && game.moves.length > 0) {
              const normalized = {
                id: Date.now() + Math.random() * 1000,
                timestamp: game.timestamp || new Date().toISOString(),
                moves: game.moves.map(m => ({
                  move: m.direction || m.move,
                  board: m.boardState || m.board
                })),
                totalMoves: game.totalMoves || game.moves.length,
                finalScore: game.finalScore || game.score || 0,
                maxTile: game.maxTile || Math.max(...(game.moves[game.moves.length - 1]?.boardState || game.moves[game.moves.length - 1]?.board || []).flat()),
                won: game.won || false,
                imported: true,
                source: file.name
              };
              gameCollection.push(normalized);
              imported++;
            }
          }
        } catch (err) {
          console.error(`Failed to import ${file.name}:`, err);
          errors++;
        }
      }
      
      // Keep max 50 games
      if (gameCollection.length > 50) {
        gameCollection = gameCollection.slice(-50);
      }
      
      saveGameCollection();
      
      const msg = `Imported ${imported} game(s)${errors > 0 ? `, ${errors} failed` : ''}. Collection now has ${gameCollection.length} games.`;
      setAiStatus(msg);
      
      // Reset file input
      document.getElementById('import-histories').value = '';
    }

    async function analyzeMultipleGames() {
      if (gameCollection.length < 2) {
        alert('Need at least 2 games in collection. Play more games or import JSON files!');
        return;
      }

      const configured = Boolean(
        azureAI.apiKey &&
        aiModels[selectedModel] &&
        !aiModels[selectedModel].endpoint.includes('YOUR-')
      );

      if (!configured) {
        alert('Please configure Azure OpenAI API key first.');
        return;
      }

      const learnFromCollectionBtn = document.getElementById('learn-from-collection');
      learnFromCollectionBtn.disabled = true;
      learnFromCollectionBtn.textContent = 'ğŸ”„ Analyzing...';
      strategyResultEl.innerHTML = `<strong>ğŸ¤– ${selectedModel} is analyzing ${gameCollection.length} games...</strong>`;
      strategyResultEl.style.display = 'block';

      // Sort games by score to identify best games
      const sortedGames = [...gameCollection].sort((a, b) => b.finalScore - a.finalScore);
      const topGames = sortedGames.slice(0, 5);
      const bottomGames = sortedGames.slice(-3);

      // Build analysis prompt with key moves from multiple games
      const formatGameSummary = (game, label) => {
        const keyMoves = [];
        // Sample key moves (early, mid, late game)
        const indices = [0, Math.floor(game.moves.length * 0.25), Math.floor(game.moves.length * 0.5), Math.floor(game.moves.length * 0.75), game.moves.length - 1];
        for (const idx of indices) {
          if (idx < game.moves.length) {
            const m = game.moves[idx];
            const boardStr = m.board.map(row => row.map(v => v === 0 ? '.' : v).join('\t')).join('\n');
            keyMoves.push(`Move ${idx + 1}: ${m.move.toUpperCase()}\n${boardStr}`);
          }
        }
        return `${label} (Score: ${game.finalScore}, ${game.totalMoves} moves, max tile ${game.maxTile}):\n${keyMoves.join('\n---\n')}`;
      };

      const prompt = `You are an expert 2048 strategy coach. Analyze these games to learn winning patterns.

=== TOP PERFORMING GAMES ===
${topGames.map((g, i) => formatGameSummary(g, `GOOD GAME ${i + 1}`)).join('\n\n======\n\n')}

=== LOWER PERFORMING GAMES ===
${bottomGames.map((g, i) => formatGameSummary(g, `WORSE GAME ${i + 1}`)).join('\n\n======\n\n')}

Compare the high-scoring games vs low-scoring games. Identify:
1. What patterns appear in HIGH-scoring games that are MISSING in low-scoring ones?
2. What mistakes appear in LOW-scoring games?
3. What are the CONSISTENT strategies that lead to success?

Respond in EXACTLY this JSON format:
{
  "style": "Name for the optimal play style based on these games",
  "rules": [
    "Rule 1: When [situation], move [direction] because [reason]",
    "Rule 2: ...",
    "Rule 3: ...",
    "Rule 4: ...",
    "Rule 5: ..."
  ],
  "cornerStrategy": "Corner anchoring pattern observed in winning games",
  "mergeStrategy": "How winning games prioritize merges",
  "emergencyMoves": "Recovery patterns when board fills up",
  "avoidPatterns": "Mistakes to avoid (seen in losing games)",
  "winningPatterns": "Key patterns that distinguish high scores from low scores",
  "summary": "2-3 sentence summary of the optimal strategy learned from these ${gameCollection.length} games"
}`;

      try {
        const model = aiModels[selectedModel];
        const url = `${model.endpoint}/openai/deployments/${model.deployment}/chat/completions?api-version=${model.apiVersion}`;
        const body = {
          messages: [
            { role: 'system', content: 'You are an expert 2048 strategy analyst. Respond only with valid JSON.' },
            { role: 'user', content: prompt }
          ],
          temperature: 0.3,
        };

        const res = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'api-key': azureAI.apiKey
          },
          body: JSON.stringify(body)
        });

        if (!res.ok) throw new Error(`${selectedModel} error: ${res.status}`);

        const data = await res.json();
        const content = data.choices?.[0]?.message?.content?.trim() || '';
        
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error('Invalid AI response format');

        const aiAnalysis = JSON.parse(jsonMatch[0]);

        learnedStrategy = {
          style: aiAnalysis.style || 'Multi-Game Learned',
          rules: aiAnalysis.rules || [],
          cornerStrategy: aiAnalysis.cornerStrategy || '',
          mergeStrategy: aiAnalysis.mergeStrategy || '',
          emergencyMoves: aiAnalysis.emergencyMoves || '',
          avoidPatterns: aiAnalysis.avoidPatterns || '',
          winningPatterns: aiAnalysis.winningPatterns || '',
          summary: aiAnalysis.summary || '',
          totalMoves: gameCollection.reduce((sum, g) => sum + g.totalMoves, 0),
          gamesAnalyzed: gameCollection.length,
          finalScore: Math.max(...gameCollection.map(g => g.finalScore)),
          analyzedByAI: true,
          multiGame: true
        };

        localStorage.setItem('aurora-2048-learned-strategy', JSON.stringify(learnedStrategy));
        displayMultiGameAnalysis();

      } catch (err) {
        console.error('Multi-game analysis error:', err);
        strategyResultEl.innerHTML = `<strong>âŒ Analysis Failed:</strong> ${err.message}`;
      } finally {
        learnFromCollectionBtn.disabled = false;
        learnFromCollectionBtn.textContent = 'ğŸ“š Learn from All Games';
      }
    }

    function displayMultiGameAnalysis() {
      if (!learnedStrategy) return;

      const { style, rules, cornerStrategy, mergeStrategy, winningPatterns, summary, gamesAnalyzed, finalScore } = learnedStrategy;

      const rulesHtml = rules && rules.length > 0 
        ? `<strong>Decision Rules:</strong><br>${rules.map(r => `â€¢ ${r}`).join('<br>')}<br>` 
        : '';
      
      const html = `
        <strong>ğŸ¤– Multi-Game Strategy (${gamesAnalyzed} games analyzed, Best: ${finalScore})</strong><br>
        <small style="color: var(--accent);">
          <strong>Style:</strong> ${style}<br>
          ${cornerStrategy ? `<strong>Corner Strategy:</strong> ${cornerStrategy}<br>` : ''}
          ${mergeStrategy ? `<strong>Merge Strategy:</strong> ${mergeStrategy}<br>` : ''}
          ${winningPatterns ? `<strong>Winning Patterns:</strong> ${winningPatterns}<br>` : ''}
          ${rulesHtml}
          ${summary ? `<strong>Summary:</strong> ${summary}<br>` : ''}
          <em>âœ“ AI will now use patterns learned from your best games!</em>
        </small>
      `;

      strategyResultEl.innerHTML = html;
      strategyResultEl.style.display = 'block';
      updateLearnedNoteDisplay();
    }

    init();
  </script>
</body>
</html>
